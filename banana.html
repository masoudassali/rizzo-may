<!DOCTYPE html>
<html>
<head>
<title>Rizzo-may!</title>
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    line-height: 1.6;
    margin: 20px;
    background-color: #f4f7f6; /* Light background */
    color: #333; /* Default text color */
    padding-bottom: 80px; /* Add padding at the bottom to make space for the fixed footer */
  }


  h2 {
    color: #333;
    border-bottom: 2px solid #007bff; /* A little underline */
    padding-bottom: 10px;
  }


  h3 {
    color: #555;
    margin-top: 0;
    margin-bottom: 10px;
  }


  p { /* Style for general paragraphs */
      margin-bottom: 15px;
  }


  ol {
    /* margin-bottom: 20px; */
    /* padding-left: 20px; */
  }


  ol li {
      /* margin-bottom: 5px; */
  }


  /* Styles for the form container using Flexbox */
  form {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid #ccc;
    border-radius: 8px; /* More rounded corners */
    background-color: #fff; /* White form background */
    box-shadow: 0 2px 4px rgba(0 0 0 / 10%); /* Subtle shadow */
    display: flex; /* Use Flexbox for the form container */
    flex-direction: column; /* Stack form sections vertically */
    gap: 20px; /* Add space between form sections */
  }


  /* Apply box-sizing for more predictable width */
  form *, form *:before, form *:after {
    box-sizing: border-box;
  }


  /* --- Specific styles for the message section to accommodate dropdown suggestions --- */
  .form-section.message-section {
      /* Changed from row to column to stack textarea and dropdown */
      flex-direction: column;
      gap: 15px; /* Adjust gap for stacked items */
      flex-wrap: wrap; /* Keep wrap for mobile, though stacking makes it less critical */
      align-items: flex-start; /* Align items to the start */
      position: relative; /* Needed for absolute positioning of dropdown panel */
  }


  .message-textarea-container {
      /* Removed flex properties as it's now stacked vertically */
      display: flex; /* Use flex to stack label and textarea inside */
      flex-direction: column;
      gap: 8px; /* Space between label and textarea */
      min-width: 280px; /* Ensure minimum width */
      width: 100%; /* Make it take full width when stacked */
      flex: none; /* Ensure it doesn't try to flex */
  }


  /* Styles for the dropdown container */
  .prompt-suggestions-dropdown {
      /* Removed flex properties as it's now stacked vertically */
      min-width: 200px; /* Keep minimum width */
      position: relative; /* Container for the absolute panel */
      align-self: flex-start; /* Align to the left under the textarea */
      display: flex; /* Use flex to arrange trigger and panel */
      flex-direction: column;
      gap: 5px; /* Space between trigger and panel */
      width: auto; /* Allow width to be determined by content/min-width */
  }


  /* Style for the dropdown trigger button */
  .dropdown-trigger {
      padding: 8px 15px;
      background-color: #e9ecef;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      text-align: left; /* Align text to the left */
      width: auto; /* Allow button width to be determined by content/padding */
      transition: background-color 0.2s ease;
      display: flex; /* Use flex to align text and arrow */
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box; /* Include padding and border in width */
      min-width: 200px; /* Match container min-width */
  }


  .dropdown-trigger:hover {
      background-color: #d0d4d7;
  }


  .dropdown-panel {
      position: absolute; /* Keep absolute positioning */
      top: auto; /* Position relative to the section, below the trigger */
      bottom: auto; /* No constraint from bottom */
      left: 0; /* Align left with the dropdown trigger */
      right: auto; /* No constraint from right */
      z-index: 100; /* Ensure it appears above other content */
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: none; /* Initially hidden */
      min-width: 250px; /* Ensure readability */
      max-height: 200px; /* Add scrolling if many items */
      overflow-y: auto; /* Enable vertical scrolling */
      flex-direction: column; /* Arrange contents vertically */
      gap: 10px; /* Space between elements */
  }


  .dropdown-panel p {
      font-weight: bold;
      margin-bottom: 0;
      font-size: 0.9em;
      color: #555;
  }


  .dropdown-panel ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* The list item with the new option */
    .dropdown-panel ul li {
        margin-bottom: 8px; /* Space between checkboxes */
        display: flex; /* Align checkbox and label */
        align-items: center;
    }

    .dropdown-panel ul li:last-child {
        margin-bottom: 0;
    }


  .dropdown-panel input[type="checkbox"] {
      margin-right: 8px; /* Space between checkbox and label */
      flex-shrink: 0; /* Prevent checkbox from shrinking */
  }


  .dropdown-panel label {
      font-weight: normal; /* Labels for checkboxes don't need to be bold */
      cursor: pointer; /* Indicate clickable */
      flex: 1; /* Allow label to take space */
      font-size: 0.9em;
  }


  .dropdown-panel #addSelectedPrompts {
      display: block; /* Make button block */
      width: 100%; /* Full width */
      padding: 8px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      margin-top: 10px; /* Space above button */
      transition: background-color 0.2s ease;
  }


  .dropdown-panel #addSelectedPrompts:hover {
      background-color: #0056b3;
  }




  /* --- End specific styles for message section --- */




  label {
    display: block; /* Labels are block elements */
    font-weight: bold;
    color: #555;
  }


  input[type="file"],
  textarea,
  input[type="text"] { /* Added input[type="text"] */
    display: block; /* Ensure they take up their flex area */
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f8f8f8;
    width: 100%; /* Make them fill the width of their parent flex item */
  }


  textarea {
      resize: vertical; /* Allow only vertical resizing */
      min-height: 100px; /* Give textarea a minimum height */
  }


   input[type="file"] {
       resize: none;
   }


    /* Styles for the container holding side-by-side document input groups */
    .document-inputs-container { /* New class */
        display: flex; /* Use Flexbox for side-by-side layout */
        gap: 20px; /* Space between the two document input groups */
        flex-wrap: wrap; /* Allow wrapping to a new line on smaller screens */
    }

    /* Style for each individual document input group (Flex items within document-inputs-container) */
    .document-input-group { /* New class */
        flex: 1; /* Allow each group to grow and shrink equally */
        min-width: 280px; /* Adjust minimum width */
        display: flex; /* Use Flexbox for elements within the group */
        flex-direction: column; /* Stack elements vertically within the group */
        gap: 5px; /* Space between elements */
        padding: 15px; /* Add some padding */
        border: 1px solid #ddd; /* Add a light border */
        border-radius: 5px; /* Slightly rounded corners */
        background-color: #f9f9f9; /* Light background */
    }

    .document-input-group label {
        margin-bottom: 0; /* Gap handles spacing */
        text-align: center; /* Center the label */
    }

    /* Adjust input styles to apply to text inputs as well */
    input[type="file"],
    textarea,
    input[type="text"] { /* Ensure text input is styled */
      display: block;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #f8f8f8;
      width: 100%; /* Make them fill the width */
      box-sizing: border-box; /* Include padding and border in width */
    }

    /* Style for disabled inputs */
    input[type="file"]:disabled,
    input[type="text"]:disabled {
        background-color: #e9e9e9;
        cursor: not-allowed;
    }


  /* Revised CSS for input[type="submit"] - use max-width and margin: auto, placed in its own section */
  input[type="submit"] {
    padding: 10px 20px; /* More padding */
    background-color: #007bff; /* Primary blue color */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s ease; /* Smooth hover effect */
    display: block; /* Make it a block element to use margin: auto for centering */
    width: auto; /* Let width be determined by content/padding initially */
    max-width: 300px; /* Limit maximum width on desktop */
    margin: 0 auto; /* Center the block button horizontally within its parent .form-section */
  }


  input[type="submit"]:hover {
    background-color: #0056b3; /* Darker blue on hover */
  }


  input[type="submit"]:disabled { /* Style for disabled button */
    background-color: #cccccc;
    cursor: not-allowed;
  }


  /* Styles for the upload status bar */
  #uploadStatusContainer {
      width: 100%;
      background-color: #ddd;
      display: none; /* Initially hidden */
      margin-top: 15px; /* Keep this margin */
      border-radius: 4px;
      overflow: hidden; /* Ensure the status bar stays within bounds */
  }


  #uploadStatusBar {
      width: 0%;
      height: 20px;
      background-color: #4CAF50; /* Green color for the bar */
      text-align: center;
      line-height: 20px; /* Vertically center text */
      color: white;
      border-radius: 4px;
      transition: width 0.3s ease; /* Smooth animation for the bar */
      font-size: 0.8em; /* Smaller text */
  }


   #uploadStatusText {
      margin-top: 5px; /* Keep this margin */
      font-size: 0.9em;
      color: #555;
      display: none; /* Initially hidden */
      text-align: center;
   }




  /* Styles for the response area */
  #responseContainer { /* Container for response header and the response area wrapper */
      margin-top: 20px; /* Keep this margin */
  }

  /* Style for the response header containing title and buttons */
  #responseHeader {
      display: flex; /* Use flexbox */
      align-items: center; /* Vertically align items */
      justify-content: space-between; /* Space out title and buttons */
      margin-bottom: 10px;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      gap: 10px; /* Space between items when wrapping */
  }

  /* Style for the heading within the response header */
  #responseHeader h3 {
      margin: 0; /* Remove default margin */
      flex-grow: 1; /* Allow heading to take available space */
  }

  /* Container for the buttons next to the header */
  .response-buttons {
      display: flex; /* Arrange buttons using flexbox */
      gap: 5px; /* Space between buttons */
      align-items: center; /* Vertically align buttons */
  }

  /* Style for the wrapper around responseArea to position the buttons (now removed) */
   .response-area-wrapper {
       position: relative; /* Needed for absolute positioning of the button */
       /* Removed absolute positioning styles for buttons */
   }


  /* Style for the response action buttons */
  #copyCodeButton,
  #downloadResumeTextButton,
  #downloadResumePdfButton, /* New PDF button */
  #editResponseButton,
  #emailResumeButton { /* Added emailResumeButton */
      background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
      border: 1px solid #ccc; /* Light border */
      border-radius: 4px; /* Small rounded corners */
      padding: 5px 8px; /* Add some padding */
      cursor: pointer;
      font-size: 0.8em; /* Smaller font size for the icon/text */
      color: #333; /* Dark color for the icon/text */
      transition: background-color 0.2s ease, border-color 0.2s ease;
      line-height: 1; /* Ensure consistent height */
      display: none; /* Initially hidden */
  }

  #copyCodeButton:hover,
  #downloadResumeTextButton:hover,
  #downloadResumePdfButton:hover, /* New PDF button */
  #editResponseButton:hover,
  #emailResumeButton:hover { /* Added emailResumeButton */
      background-color: rgba(255, 255, 255, 1); /* Less transparent on hover */
      border-color: #bbb;
  }


  /* Optional: Style for when the text is copied */
  #copyCodeButton.copied {
      background-color: #d4edda; /* Light green */
      border-color: #c3e6cb; /* Green border */
      color: #155724; /* Dark green text */
  }

   /* Optional: Style for when the text is downloaded */
  #downloadResumeTextButton.downloaded,
  #downloadResumePdfButton.downloaded { /* New PDF button */
      background-color: #d4edda; /* Light green */
      border-color: #c3e6cb; /* Green border */
      color: #155724; /* Dark green text */
  }
  /* Optional: Style for when email is opened */
  #emailResumeButton.emailed {
      background-color: #d1ecf1; /* Light blue */
      border-color: #bee5eb; /* Blue border */
      color: #0c5460; /* Dark blue text */
  }


    #quillCustomToolbar {
        display: none;
        margin-bottom: 0;
    }

    #editor {
        width: 100%;
        box-sizing: border-box;
        color: #333;
        font-family: inherit;
        font-size: inherit;
        margin-bottom: 10px;
        display: none;
    }

    .ql-toolbar.ql-snow {
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        background-color: #f8f8f8;
        border: 1px solid #eee;
        border-bottom: none;
        box-sizing: border-box;
    }

    .ql-container.ql-snow {
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        min-height: 200px;
        font-family: inherit;
        font-size: inherit;
        color: #333;
        border: 1px solid #eee;
        background-color: #fff;
        box-sizing: border-box;
    }

    .ql-editor {
        min-height: 200px;
        padding: 12px 15px;
        box-sizing: border-box;
        overflow-y: auto;
    }


  #responseArea {
    padding: 15px;
    border: 1px solid #eee;
    border-radius: 8px;
    background-color: #e9ecef;
    white-space: pre-wrap;
    word-wrap: break-word;
    min-height: 50px;
    color: #333;
    overflow-x: auto;
    padding-right: 15px;
  }


  #responseArea pre {
      margin: 0;
      padding: 0;
      white-space: pre-wrap;
  }




  #responseArea p {
      margin: 5px 0;
      padding: 0;
  }


  #responseArea code {
      background-color: #f8f9fa;
      padding: 2px 4px;
      border-radius: 4px;
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
      font-size: 0.9em;
  }


  #responseArea {
      overflow-y: hidden;
      overflow-x: auto;
  }


  #doneEditingButton {
      display: block;
      width: auto;
      padding: 8px 15px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      margin: 10px auto;
      transition: background-color 0.2s ease;
  }

  #doneEditingButton:hover {
      background-color: #218838;
  }


  /* Styles for the footer */
  footer {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      background-color: #333;
      color: #f4f7f6;
      text-align: center;
      padding: 10px 20px;
      font-size: 0.8em;
      z-index: 10;
  }


  footer p {
      margin: 0;
      padding: 0;
  }


    footer a {
        color: #f4f7f6;
        text-decoration: none;
    }


    footer a:hover {
        text-decoration: underline;
    }


    footer #submissionCountDisplay {
        font-weight: bold;
        margin-left: 5px;
    }




  @media (max-width: 768px) {
      body {
          margin: 10px;
          padding-bottom: 100px;
      }
      form {
          padding: 15px;
      }
      .form-section.message-section {
          flex-direction: column;
          gap: 15px;
          align-items: stretch;
      }
       .message-textarea-container,
       .prompt-suggestions-dropdown {
           flex: none;
           width: 100%;
           min-width: auto;
       }
       .prompt-suggestions-dropdown {
           position: static;
           padding-bottom: 0;
           gap: 5px;
       }


      .dropdown-panel {
          position: static;
          width: 100%;
          max-height: none;
          overflow-y: visible;
          border: none;
          box-shadow: none;
          padding: 0;
          gap: 10px;
      }
       .dropdown-panel p {
           margin-top: 10px;
       }
       .dropdown-panel ul {
           padding-left: 20px;
       }
       .dropdown-panel li {
           margin-bottom: 8px;
       }




      input[type="submit"] {
          width: 100%;
          max-width: none;
          margin: 0;
          text-align: center;
      }
      .button-section {
          align-items: stretch;
      }


       .document-inputs-container {
           flex-direction: column;
           gap: 15px;
       }
       .document-input-group {
           min-width: auto;
           width: 100%;
           padding: 10px;
       }

      #responseHeader {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
      }

      .response-buttons {
          width: 100%;
          justify-content: flex-start;
      }


       #copyCodeButton,
       #downloadResumeTextButton,
       #downloadResumePdfButton, /* New PDF button */
       #editResponseButton,
       #emailResumeButton {
           position: static;
           margin-top: 0;
           display: inline-block;
           width: auto;
           text-align: center;
       }

        .response-area-wrapper {
            position: static;
        }
        #responseArea {
            padding-top: 15px;
            padding-right: 15px;
        }

        #editor {
            /* padding-right: 15px; */
        }


        #doneEditingButton {
            width: 100%;
            margin: 10px 0;
        }


        footer {
            font-size: 0.7em;
            padding: 8px 10px;
            line-height: 1.4;
        }
        footer p {
            margin: 0;
        }
  }
</style>
</head>
<body>


<h2>Rizzo-may! <span style="font-size: smaller;"><i>(beta)</i></span></h2>
<p>Of course you may use AI to customize your resume to job applications. <b><i>(it's free.)</i></b><br><b>3 simple steps: </b></p>

<form id="uploadForm" enctype="multipart/form-data" action="https://steak.servequake.com/webhook/19776e0c-4a2e-447c-972e-e7d27b83e6b5" method="POST">
  <div class="form-section message-section">
    <div class="message-textarea-container">
        <label for="userMessage">[Optional] Add a focus to your resume. (Choose from the suggestions below or add your own.)</label>
        <textarea name="userMessage" id="userMessage" rows="4" cols="50"></textarea>
    </div>
    <div class="prompt-suggestions-dropdown">
        <button id="promptDropdownTrigger" class="dropdown-trigger">Add Suggestions <span class="arrow">▼</span></button>
        <div id="promptDropdownPanel" class="dropdown-panel">
            <button id="addSelectedPrompts">Add Selected</button>
            <p>Select suggestions to add:</p>
            <ul>
                <li><input type="checkbox" id="prompt-1" data-prompt="Clean up and proofread"><label for="prompt-1">Clean up and proofread</label></li>
                <li><input type="checkbox" id="prompt-4" data-prompt="Incorporate ATS keywords"><label for="prompt-4">Incorporate ATS keywords</label></li>
                <li><input type="checkbox" id="prompt-5" data-prompt="Strengthen using action verbs and numbers"><label for="prompt-5">Strengthen using action verbs and numbers</label></li>
                <li><input type="checkbox" id="prompt-6" data-prompt="Condense to one page"><label for="prompt-6">Condense to one page</label></li>
                 <li><input type="checkbox" id="prompt-2" data-prompt="Use [Industry] terms"><label for="prompt-2">Use [Industry] terms</label></li>
                <li><input type="checkbox" id="prompt-3" data-prompt="Emphasize [Skill] experience"><label for="prompt-3">Emphasize [Skill] experience</label></li>
                 <li><input type="checkbox" id="prompt-haiku" data-prompt="Write every line as a haiku to follow a 5-7-5 syllable structure"><label for="prompt-haiku">Write as a haiku 🐰🥚</label></li>
                </ul>
        </div>
    </div>
  </div>

  <div class="form-section">
    <p><b>Provide your Resume and the Job Description:</b> <i>(.txt, .pdf, .docx files < 1mb please. You can mix & match formats and input types.)</i></p>

    <div class="document-inputs-container"> <div class="document-input-group"> <label for="resumeInput">Add Resume:</label> <input type="file" name="resumeFile" id="resumeFile"> <p style="text-align: center; margin: 5px 0; font-size: 0.9em; color: #555;">- OR -</p>
        <input type="text" name="resumeUrl" id="resumeUrl" placeholder="Enter Resume URL"> </div>

      <div class="document-input-group"> <label for="jdInput">Add Job Description:</label> <input type="file" name="jdFile" id="jdFile"> <p style="text-align: center; margin: 5px 0; font-size: 0.9em; color: #555;">- OR -</p>
        <input type="text" name="jdUrl" id="jdUrl" placeholder="Enter JD URL"> </div>

    </div>
     <p style="font-size: 0.9em; color: #666; margin-top: 5px;"><i>(For each document, provide either a file upload OR a URL.)</i></p>
  </div>
  <div class="form-section button-section">
    <input type="submit" value="Generate Resume">
  </div>


</form>


<div id="uploadStatusContainer">
  <div id="uploadStatusBar">0%</div>
</div>
<div id="uploadStatusText">Uploading...</div>




<div id="responseContainer" style="display: none;">
    <div id="responseHeader">
        <h3>Your customized Rizzo-may:</h3><b>
          <h4><i>(In case of error, please check you file format. I'll add OCR capabilities soon.)</i></h4>
        <div class="response-buttons">
            <button id="editResponseButton" title="Edit on the spot">Edit</button>
            <button id="emailResumeButton" title="Send as Email">📧 Email</button> <button id="copyCodeButton" title="Copy to clipboard">📋 Copy</button>
            <button id="downloadResumeTextButton" title="Download as Text">⬇️ Download Text</button>
            <button id="downloadResumePdfButton" title="Download as PDF">⬇️ Download PDF</button>
        </div>
    </div>
    <div id="quillCustomToolbar" style="display: none;"></div>
    <div class="response-area-wrapper">
        <div id="responseArea"></div>
        <div id="editor" style="display: none;"></div>
        <button id="doneEditingButton" style="display: none;" title="Done Editing">✅ Done Editing</button>
    </div>
</div>

<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.2/html2pdf.bundle.min.js"></script>

<script>
// Global variable for the counter span element
let counterDisplaySpan = null;
const localStorageKey = 'rizzoooMaySubmissionCount';
let currentCount = localStorage.getItem(localStorageKey); // Read initial count globally
let quill = null; // Variable to hold the Quill editor instance


document.addEventListener('DOMContentLoaded', function() {
    // --- Get common DOM elements once ---
    counterDisplaySpan = document.getElementById('submissionCountDisplay');
    const dropdownTrigger = document.getElementById('promptDropdownTrigger');
    const dropdownPanel = document.getElementById('promptDropdownPanel');
    const addSelectedButton = document.getElementById('addSelectedPrompts');
    const resumeFile = document.getElementById('resumeFile');
    const resumeUrl = document.getElementById('resumeUrl');
    const jdFile = document.getElementById('jdFile');
    const jdUrl = document.getElementById('jdUrl');
    const uploadForm = document.getElementById('uploadForm');
    const responseArea = document.getElementById('responseArea');
    const editorContentArea = document.getElementById('editor');
    const quillCustomToolbarContainer = document.getElementById('quillCustomToolbar');

    // Response action buttons
    const editResponseButton = document.getElementById('editResponseButton');
    const copyCodeButton = document.getElementById('copyCodeButton');
    const downloadResumeTextButton = document.getElementById('downloadResumeTextButton'); // Renamed
    const downloadResumePdfButton = document.getElementById('downloadResumePdfButton'); // New PDF button
    const emailResumeButton = document.getElementById('emailResumeButton');
    const doneEditingButton = document.getElementById('doneEditingButton');


    // --- Submission Counter Initialization ---
    if (!counterDisplaySpan) {
        console.error("Submission count display span not found in footer! Counter will not display.");
    } else {
        if (currentCount === null || isNaN(parseInt(currentCount, 10))) {
            currentCount = 431;
            localStorage.setItem(localStorageKey, currentCount);
        } else {
             currentCount = parseInt(currentCount, 10);
        }
        counterDisplaySpan.textContent = currentCount;
    }


    // --- Prompt Suggestions Dropdown Functionality ---
    if (dropdownTrigger && dropdownPanel && addSelectedButton) {
        dropdownTrigger.addEventListener('click', function(event) {
            event.preventDefault(); // Prevent default browser click behavior
            event.stopPropagation(); // Stop event from bubbling up to document
            const isVisible = dropdownPanel.style.display === 'flex';
            dropdownPanel.style.display = isVisible ? 'none' : 'flex';
            const arrow = this.querySelector('.arrow');
            if(arrow) {
                arrow.textContent = isVisible ? '▼' : '▲';
            }
        });

        // Close dropdown if clicked outside
        document.addEventListener('click', function(event) {
            if (dropdownPanel && !dropdownTrigger.contains(event.target) && !dropdownPanel.contains(event.target)) {
                dropdownPanel.style.display = 'none';
                 const arrow = dropdownTrigger.querySelector('.arrow');
                 if(arrow) { arrow.textContent = '▼'; }
            }
        });

        // Prevent clicks inside dropdown from closing it immediately
        dropdownPanel.addEventListener('click', function(event) {
            event.stopPropagation();
        });

        // Add selected prompts to textarea
        addSelectedButton.addEventListener('click', function(event) {
            event.preventDefault(); // Prevent default button click
            const textarea = document.getElementById('userMessage');
            const checkboxes = dropdownPanel.querySelectorAll('input[type="checkbox"]:checked');
            let selectedPromptsText = '';

            checkboxes.forEach(checkbox => {
                const promptText = checkbox.dataset.prompt || checkbox.nextElementSibling.textContent.trim(); // Use dataset.prompt or label text, trim whitespace
                selectedPromptsText += promptText + '\n';
                checkbox.checked = false; // Deselect after adding
            });

            if (selectedPromptsText.length > 0 && textarea) {
                 // Add a newline prefix only if textarea is not empty and doesn't already end with a newline
                 const prefix = textarea.value.length > 0 && !textarea.value.endsWith('\n') ? '\n' : '';
                 textarea.value += prefix + selectedPromptsText;
                 textarea.scrollTop = textarea.scrollHeight; // Scroll to bottom
                 textarea.focus(); // Put cursor back in textarea
            }
            dropdownPanel.style.display = 'none'; // Close dropdown after adding
            const arrow = dropdownTrigger.querySelector('.arrow');
            if(arrow) { arrow.textContent = '▼'; }
        });
    }


    // --- Mutually Exclusive Document Input (File or URL) ---
    const updateResumeInputState = () => {
        if (resumeUrl && resumeFile) {
            if (resumeUrl.value.trim() !== '') {
                resumeFile.disabled = true;
            } else {
                resumeFile.disabled = false;
            }
        }
    };

    const updateJdInputState = () => {
        if (jdUrl && jdFile) {
            if (jdUrl.value.trim() !== '') {
                jdFile.disabled = true;
            } else {
                jdFile.disabled = false;
            }
        }
    };

    if (resumeUrl && resumeFile && jdUrl && jdFile) {
        resumeUrl.addEventListener('input', updateResumeInputState);
        resumeFile.addEventListener('change', () => {
            if (resumeFile.files.length > 0) {
                resumeUrl.value = ''; // Clear URL if file is selected
            }
            updateResumeInputState();
        });
        jdUrl.addEventListener('input', updateJdInputState);
        jdFile.addEventListener('change', () => {
            if (jdFile.files.length > 0) {
                jdUrl.value = ''; // Clear URL if file is selected
            }
            updateJdInputState();
        });
        // Set initial state on page load
        updateResumeInputState();
        updateJdInputState();
    }


    // --- Form Submission ---
    if (uploadForm) {
        uploadForm.addEventListener('submit', function(event) {
            event.preventDefault(); // Prevent default form submission

            console.log("Form submit triggered."); // Log when the submit handler runs
            // Diagnostic log: Check value right before creating FormData
            const userMessageTextarea = document.getElementById('userMessage');
            console.log("Value of userMessage just before FormData:", userMessageTextarea ? userMessageTextarea.value : "Textarea not found"); // Diagnostic line


            const form = this;
            const responseContainer = document.getElementById('responseContainer');
            const uploadStatusContainer = document.getElementById('uploadStatusContainer');
            const uploadStatusBar = document.getElementById('uploadStatusBar');
            const uploadStatusText = document.getElementById('uploadStatusText');
            const submitButton = form.querySelector('input[type="submit"]');

            // --- Get elements for editing feature ---
            const editorContainer = document.getElementById('editor'); // The div for Quill editor
            const editResponseButton = document.getElementById('editResponseButton'); // The Edit button
            const doneEditingButton = document.getElementById('doneEditingButton'); // The Done Editing button
            const copyCodeButton = document.getElementById('copyCodeButton'); // The Copy button
            const downloadResumeTextButton = document.getElementById('downloadResumeTextButton'); // The Download Text button (renamed)
            const downloadResumePdfButton = document.getElementById('downloadResumePdfButton'); // The Download PDF button (new)
            const emailResumeButton = document.getElementById('emailResumeButton'); // New email button


            // Add validation: Check if either a file OR a URL is provided for Resume and JD
            const isResumeProvided = (resumeFile && resumeFile.files && resumeFile.files.length > 0) || (resumeUrl && resumeUrl.value.trim() !== '');
            const isJdProvided = (jdFile && jdFile.files && jdFile.files.length > 0) || (jdUrl && jdUrl.value.trim() !== '');


            if (!isResumeProvided || !isJdProvided) {
                alert("Please provide either a file or a URL for both your Resume and the Job Description.");
                // Re-enable form elements and hide status bar if validation fails
                if(submitButton) submitButton.disabled = false;
                reEnableForm(); // Use the helper function to re-enable
                if(uploadStatusContainer) uploadStatusContainer.style.display = 'none';
                if(uploadStatusText) uploadStatusText.style.display = 'none';
                return; // Stop the submission process
            }

            const formData = new FormData(form); // Use form instead of this for clarity


            // Helper function to re-enable form elements, excluding action buttons and dropdown controls
            const reEnableForm = () => {
                  updateResumeInputState(); // Re-run state logic for file/url
                  updateJdInputState(); // Re-run state logic for file/url
                  // Re-enable all form elements except the submit button, editing buttons, and dropdown trigger/panel contents
                  form.querySelectorAll('input, textarea, button').forEach(element => {
                     // Check if the element is NOT one of the action buttons or part of the dropdown panel/trigger
                     if (element !== submitButton &&
                         element !== editResponseButton &&
                         element !== doneEditingButton &&
                         element !== copyCodeButton &&
                         element !== downloadResumeTextButton && // Check for renamed button
                         element !== downloadResumePdfButton && // Check for new button
                         element !== emailResumeButton &&
                         element.id !== 'promptDropdownTrigger' && // Don't disable the trigger button
                         !element.closest('.prompt-suggestions-dropdown') // Don't disable anything inside the dropdown panel (checkboxes, Add Selected button)
                         ) {
                         element.disabled = false;
                     }
                 });
            };


            // Disable form elements during submission
            form.querySelectorAll('input, textarea, button').forEach(element => {
                 // Exclude action buttons and dropdown controls from being disabled here
                 if (element !== submitButton &&
                     element !== editResponseButton &&
                     element !== doneEditingButton &&
                     element !== copyCodeButton &&
                     element !== downloadResumeTextButton && // Check for renamed button
                     element !== downloadResumePdfButton && // Check for new button
                     element !== emailResumeButton &&
                     element.id !== 'promptDropdownTrigger' && // Don't disable the trigger button
                     !element.closest('.prompt-suggestions-dropdown') // Don't disable anything inside the dropdown panel
                     ) {
                     element.disabled = true;
                 }
             });
            if(submitButton) submitButton.disabled = true; // Disable the submit button specifically


            // Show initial generating/uploading state
            if(responseContainer) responseContainer.style.display = 'block';
            if(responseArea) {
                responseArea.innerHTML = 'Generating... shouldn\'t take more than a couple of minutes.';
                responseArea.style.color = '#000';
                responseArea.style.backgroundColor = '#e9ecef';
                responseArea.style.borderColor = '#eee';
                responseArea.style.display = 'block';
                // Ensure editor is hidden if shown
                if(editorContainer) editorContainer.style.display = 'none';
                if(quillCustomToolbarContainer) quillCustomToolbarContainer.style.display = 'none';
                if(doneEditingButton) doneEditingButton.style.display = 'none';
            }

            // Hide action buttons initially
            if(editResponseButton) editResponseButton.style.display = 'none';
            if(copyCodeButton) copyCodeButton.style.display = 'none';
            if(downloadResumeTextButton) downloadResumeTextButton.style.display = 'none'; // Hide renamed button
            if(downloadResumePdfButton) downloadResumePdfButton.style.display = 'none'; // Hide new button
            if(emailResumeButton) emailResumeButton.style.display = 'none';


            const isUploadingFiles = (resumeFile && resumeFile.files && resumeFile.files.length > 0) || (jdFile && jdFile.files && jdFile.files.length > 0);
            const isProcessingUrls = (resumeUrl && resumeUrl.value.trim() !== '') || (jdUrl && jdUrl.value.trim() !== '');

            if(uploadStatusContainer) uploadStatusContainer.style.display = 'block';
            if(uploadStatusText) uploadStatusText.style.display = 'block';
            if(uploadStatusBar) {
                uploadStatusBar.style.width = '0%';
                uploadStatusBar.innerHTML = '0%';
            }

            if (isUploadingFiles) {
                if(uploadStatusText) uploadStatusText.innerHTML = "Initiating file upload...";
            } else if (isProcessingUrls) {
                if(uploadStatusText) uploadStatusText.innerHTML = "Sending data for URL processing...";
            } else {
                if(uploadStatusText) uploadStatusText.innerHTML = "Preparing request..."; // Should not happen with validation
            }


            const xhr = new XMLHttpRequest();

            // --- XHR Event Handlers ---
            xhr.upload.onprogress = function(event) {
                if (event.lengthComputable) {
                    const percentComplete = (event.loaded / event.total) * 100;
                    const percent = Math.round(percentComplete);
                    if(uploadStatusBar) {
                        uploadStatusBar.style.width = percent + '%';
                        uploadStatusBar.innerHTML = percent + '%';
                    }
                    if (isUploadingFiles) {
                        if(uploadStatusText) uploadStatusText.innerHTML = `Uploading files (${percent}%)...`;
                    } else {
                        // For non-file uploads, progress might jump straight to 100 or not fire
                        if(uploadStatusText && percent > 0) uploadStatusText.innerHTML = `Sending data (${percent}%)...`;
                    }
                }
            };

            xhr.upload.onload = function() {
                // This fires when upload portion is complete, not entire request
                console.log("XHR Upload Complete");
                 if(uploadStatusBar) {
                    uploadStatusBar.style.width = '100%';
                    uploadStatusBar.innerHTML = '100%';
                }
                 if(uploadStatusText) {
                     if (isUploadingFiles) {
                         uploadStatusText.innerHTML = "Upload complete. Waiting for server processing...";
                     } else {
                         uploadStatusText.innerHTML = "Data sent. Waiting for server response...";
                     }
                 }
            };

            xhr.onload = function() {
                console.log("XHR Load Complete. Status:", xhr.status);
                reEnableForm(); // Re-enable form elements

                // Update status bar final state
                if(uploadStatusBar) {
                   uploadStatusBar.innerHTML = xhr.status >= 200 && xhr.status < 300 ? 'Complete!' : 'Error!';
                   uploadStatusBar.style.backgroundColor = xhr.status >= 200 && xhr.status < 300 ? '#4CAF50' : '#f44336'; // Green or Red
                }


                if (xhr.status >= 200 && xhr.status < 300) {
                    // Success response
                    if (counterDisplaySpan) {
                         // Ensure currentCount is a number before incrementing
                         if (typeof currentCount !== 'number' || isNaN(currentCount)) {
                             // Try reading from localStorage again as fallback
                             const storedCount = localStorage.getItem(localStorageKey);
                             currentCount = storedCount === null || isNaN(parseInt(storedCount, 10)) ? 431 : parseInt(storedCount, 10);
                         }
                        currentCount++; // Increment count on successful generation
                        localStorage.setItem(localStorageKey, currentCount); // Save updated count
                        counterDisplaySpan.textContent = currentCount; // Update display
                    }

                    try {
                        const data = JSON.parse(xhr.responseText);
                        // Assuming the resume text is in data.customizedResume
                        const customizedResumeText = data.customizedResume || 'Error: "customizedResume" field not found in response.'; // Provide fallback text
                        if(responseArea) {
                             // Display response in responseArea
                             // Handle potential HTML or just plain text output
                             // If response is plain text, wrap in <pre> or convert newlines to <br>
                             if (customizedResumeText && typeof customizedResumeText === 'string' && !customizedResumeText.trim().startsWith('<')) {
                                 responseArea.innerHTML = '<pre>' + escapeHTML(customizedResumeText) + '</pre>'; // Use <pre> for plain text, escape HTML entities
                             } else if (customizedResumeText) {
                                 responseArea.innerHTML = customizedResumeText; // Assume it's HTML or error message
                             } else {
                                 responseArea.innerHTML = 'Generated response is empty.';
                             }

                             responseArea.style.display = 'block'; // Ensure response area is visible
                         }


                        if(uploadStatusText) uploadStatusText.innerHTML = "Generated!"; // Final status text
                         // Reset response area styles to normal on success
                        if(responseArea) {
                            responseArea.style.color = '#333';
                            responseArea.style.backgroundColor = '#e9ecef';
                            responseArea.style.borderColor = '#eee';
                        }


                        // Show action buttons on success
                        const isMobile = window.innerWidth <= 768;
                        const displayStyle = isMobile ? 'block' : 'inline-block';

                        if(editResponseButton) editResponseButton.style.display = displayStyle;
                        if(copyCodeButton) copyCodeButton.style.display = displayStyle;
                        if(downloadResumeTextButton) downloadResumeTextButton.style.display = displayStyle; // Show renamed button
                        if(downloadResumePdfButton) downloadResumePdfButton.style.display = displayStyle; // Show new button
                        if(emailResumeButton) emailResumeButton.style.display = displayStyle;


                    } catch (e) {
                        // Handle JSON parsing errors or unexpected response structure
                        console.error('Error parsing JSON response:', e, 'Response:', xhr.responseText);
                        if(responseArea) {
                            responseArea.innerHTML = '<p>Error: Received unexpected response format.</p><p><code>' + escapeHTML(xhr.responseText || 'No response text').substring(0, 500) + '...</code></p>'; // Display error with raw response snippet
                             // Set error styles for response area
                            responseArea.style.color = '#721c24';
                            responseArea.style.backgroundColor = '#f8d7da';
                            responseArea.style.borderColor = '#f5c6cb';
                             responseArea.style.display = 'block'; // Ensure response area is visible
                        }

                        if(uploadStatusText) uploadStatusText.innerHTML = "Generation failed (Parse Error)."; // Final status text

                        // Hide action buttons on error
                        if(editResponseButton) editResponseButton.style.display = 'none';
                        if(copyCodeButton) copyCodeButton.style.display = 'none';
                        if(downloadResumeTextButton) downloadResumeTextButton.style.display = 'none'; // Hide renamed button
                        if(downloadResumePdfButton) downloadResumePdfButton.style.display = 'none'; // Hide new button
                        if(emailResumeButton) emailResumeButton.style.display = 'none';
                    }
                } else {
                    // Handle HTTP errors (status not 2xx)
                    console.error('HTTP error!', xhr.status, xhr.responseText);
                    let errorMessage = `HTTP error! status: ${xhr.status}`;
                    try {
                        const errorResponse = JSON.parse(xhr.responseText);
                        if (errorResponse.message) {
                            errorMessage += `, message: ${errorResponse.message}`;
                        } else {
                             // If JSON has no 'message', just show a snippet of the response
                            errorMessage += `, body: ${escapeHTML(xhr.responseText).substring(0, 200)}...`;
                        }
                    } catch (e) {
                         // If response is not JSON, just show a snippet
                        errorMessage += `, body: ${escapeHTML(xhr.responseText).substring(0, 200)}...`;
                    }

                    if(responseArea) {
                         responseArea.innerHTML = '<p>Error processing request:</p><p><code>' + errorMessage + '</code></p>'; // Display error message
                         // Set error styles for response area
                        responseArea.style.color = '#721c24';
                        responseArea.style.backgroundColor = '#f8d7da';
                        responseArea.style.borderColor = '#f5c6cb';
                         responseArea.style.display = 'block'; // Ensure response area is visible
                    }

                    if(uploadStatusText) uploadStatusText.innerHTML = `Error: ${xhr.status}`; // Final status text

                    // Hide action buttons on error
                    if(editResponseButton) editResponseButton.style.display = 'none';
                    if(copyCodeButton) copyCodeButton.style.display = 'none';
                    if(downloadResumeTextButton) downloadResumeTextButton.style.display = 'none'; // Hide renamed button
                    if(downloadResumePdfButton) downloadResumePdfButton.style.display = 'none'; // Hide new button
                    if(emailResumeButton) emailResumeButton.style.display = 'none';
                }
                 // Hide upload status bar and text after request is complete (success or error)
                if(uploadStatusContainer) uploadStatusContainer.style.display = 'none';
                if(uploadStatusText) uploadStatusText.style.display = 'none';
            };

            xhr.onerror = function() {
                // Handle network connection errors
                console.error('Network error!');
                 // Hide upload status bar and text
                if(uploadStatusContainer) uploadStatusContainer.style.display = 'none';
                if(uploadStatusText) uploadStatusText.style.display = 'none';
                reEnableForm(); // Re-enable form elements

                if(responseArea) {
                     responseArea.innerHTML = '<p>Error processing request:</p><p><code>Network request failed. Please check your connection or the server status.</code></p>'; // Display network error message
                     // Set error styles for response area
                    responseArea.style.color = '#721c24';
                    responseArea.style.backgroundColor = '#f8d7da';
                    responseArea.style.borderColor = '#f5c6cb';
                     responseArea.style.display = 'block'; // Ensure response area is visible
                }
                 if(uploadStatusBar) {
                     uploadStatusBar.innerHTML = "Error!";
                     uploadStatusBar.style.backgroundColor = '#f44336'; // Red
                 }

                // Hide action buttons on error
                if(editResponseButton) editResponseButton.style.display = 'none';
                if(copyCodeButton) copyCodeButton.style.display = 'none';
                if(downloadResumeTextButton) downloadResumeTextButton.style.display = 'none'; // Hide renamed button
                if(downloadResumePdfButton) downloadResumePdfButton.style.display = 'none'; // Hide new button
                if(emailResumeButton) emailResumeButton.style.display = 'none';
            };

            xhr.ontimeout = function() {
                // Handle request timeout
                console.error('Request timed out!');
                 // Hide upload status bar and text
                if(uploadStatusContainer) uploadStatusContainer.style.display = 'none';
                if(uploadStatusText) uploadStatusText.style.display = 'none';
                reEnableForm(); // Re-enable form elements

                if(responseArea) {
                     responseArea.innerHTML = '<p>Error processing request:</p><p><code>Request timed out. The server took too long to respond.</code></p>'; // Display timeout message
                     // Set error styles for response area
                    responseArea.style.color = '#721c24';
                    responseArea.style.backgroundColor = '#f8d7da';
                    responseArea.style.borderColor = '#f5c6cb';
                     responseArea.style.display = 'block'; // Ensure response area is visible
                }
                 if(uploadStatusBar) {
                     uploadStatusBar.innerHTML = "Timeout!";
                     uploadStatusBar.style.backgroundColor = '#f44336'; // Red
                 }

                // Hide action buttons on error
                if(editResponseButton) editResponseButton.style.display = 'none';
                if(copyCodeButton) copyCodeButton.style.display = 'none';
                if(downloadResumeTextButton) downloadResumeTextButton.style.display = 'none'; // Hide renamed button
                if(downloadResumePdfButton) downloadResumePdfButton.style.display = 'none'; // Hide new button
                if(emailResumeButton) emailResumeButton.style.display = 'none';
            };
            xhr.open(this.method, this.action);
            // No need to set Content-Type header for FormData, browser does it correctly including boundary
            xhr.send(formData);
        });
    }


    // --- Quill Initialization and Toolbar Management ---
    const toolbarOptions = [
        ['bold', 'italic', 'underline', 'strike'], ['blockquote', 'code-block'],
        [{ 'header': 1 }, { 'header': 2 }], [{ 'list': 'ordered'}, { 'list': 'bullet' }],
        [{ 'script': 'sub'}, { 'script': 'super' }], [{ 'indent': '-1'}, { 'indent': '+1' }],
        [{ 'direction': 'rtl' }], [{ 'size': ['small', false, 'large', 'huge'] }],
        [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
        [{ 'color': [] }, { 'background': [] }], [{ 'font': [] }], [{ 'align': [] }],
        ['clean']
    ];

    if (editorContentArea) {
        quill = new Quill(editorContentArea, {
            modules: { toolbar: toolbarOptions },
            theme: 'snow'
        });

        // Move the generated Quill toolbar to the custom container
        const createdToolbar = editorContentArea.querySelector('.ql-toolbar');
        if (createdToolbar && quillCustomToolbarContainer) {
            quillCustomToolbarContainer.appendChild(createdToolbar);
        } else {
            console.error('Quill toolbar or custom container not found for moving.');
        }
    }


    // --- Edit/View Mode Switching ---
    const switchToEditMode = () => {
        // Ensure necessary elements exist
        if (!quill || !responseArea || !editorContentArea || !quillCustomToolbarContainer || !doneEditingButton || !editResponseButton || !copyCodeButton || !downloadResumeTextButton || !downloadResumePdfButton || !emailResumeButton) {
            console.error("Missing elements for edit mode switch.");
            return;
        }

        let contentToEdit = '';
        const responseAreaContent = responseArea.innerHTML.trim();

        // Check if responseArea has content and is plain text wrapped in <pre>
        if (responseAreaContent.startsWith('<pre>') && responseAreaContent.endsWith('</pre>')) {
            contentToEdit = responseArea.firstChild.innerText; // Get plain text from inside <pre>
            // Convert plain text with newlines to Quill's paragraph format
             contentToEdit = contentToEdit.split('\n').map(line => `<p>${escapeHTML(line) || '<br>'}</p>`).join('');

        } else if (responseAreaContent) {
             // Assume it might be HTML (e.g., if AI outputted HTML directly or had error formatting)
             // Or if it's plain text without <pre>, convert newlines to <br> within a single <p>
             // A robust solution might parse HTML, but for simplicity, treat as plain text unless it's clearly structured HTML
             if (!responseAreaContent.match(/<\s*[a-zA-Z][^>]*>/i)) { // Check if it doesn't contain common HTML tags
                  contentToEdit = responseArea.innerText; // Get plain text value
                  contentToEdit = contentToEdit.split('\n').map(line => `<p>${escapeHTML(line) || '<br>'}</p>`).join('');
             } else {
                  // If it looks like HTML, load it directly (be cautious of arbitrary HTML)
                  contentToEdit = responseAreaContent;
             }

        } else {
            // If responseArea is empty
            contentToEdit = ''; // Start with empty editor
        }


        quill.root.innerHTML = contentToEdit; // Set editor content
        responseArea.style.display = 'none'; // Hide view mode area

        // Hide action buttons during edit
        editResponseButton.style.display = 'none';
        copyCodeButton.style.display = 'none';
        downloadResumeTextButton.style.display = 'none';
        downloadResumePdfButton.style.display = 'none'; // Hide new button
        emailResumeButton.style.display = 'none';

        // Show editor and done button
        quillCustomToolbarContainer.style.display = 'block';
        editorContentArea.style.display = 'block';
        doneEditingButton.style.display = 'block';

        quill.focus(); // Focus the editor for immediate typing
    };

    const switchToViewMode = () => {
        // Ensure necessary elements exist
        if (!quill || !responseArea || !editorContentArea || !quillCustomToolbarContainer || !doneEditingButton || !editResponseButton || !copyCodeButton || !downloadResumeTextButton || !downloadResumePdfButton || !emailResumeButton) {
            console.error("Missing elements for view mode switch.");
            return;
        }

        const editedHtml = quill.root.innerHTML; // Get HTML content from editor
        responseArea.innerHTML = editedHtml; // Set content in view mode area

        // Hide editor and done button
        quillCustomToolbarContainer.style.display = 'none';
        editorContentArea.style.display = 'none';
        doneEditingButton.style.display = 'none';

        // Show view mode area and action buttons
        responseArea.style.display = 'block';

        const isMobile = window.innerWidth <= 768;
        const displayStyle = isMobile ? 'block' : 'inline-block';

        editResponseButton.style.display = displayStyle;
        copyCodeButton.style.display = displayStyle;
        downloadResumeTextButton.style.display = displayStyle; // Show renamed button
        downloadResumePdfButton.style.display = displayStyle; // Show new button
        emailResumeButton.style.display = displayStyle;
    };

    // Helper function to escape HTML entities
    function escapeHTML(str) {
        const div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }


    if (editResponseButton) editResponseButton.addEventListener('click', switchToEditMode);
    if (doneEditingButton) doneEditingButton.addEventListener('click', switchToViewMode);

    // --- Action Button Event Listeners ---
    if (copyCodeButton) {
        copyCodeButton.addEventListener('click', function() {
            // Determine the source element for text: responseArea (view) or editor (edit)
            const sourceElement = responseArea.style.display !== 'none' ? responseArea : (quill ? quill.root : null); // Use quill.root for the editor's content div


            let textToCopy = '';

            if (sourceElement) {
                 if (sourceElement === responseArea) {
                     // If in view mode, get the visible text, preserving line breaks
                     // If it's a <pre>, get innerText. Otherwise, get innerText and handle newlines.
                     if (responseArea.firstChild && responseArea.firstChild.nodeName === 'PRE') {
                         textToCopy = responseArea.firstChild.innerText;
                     } else {
                          // Attempt to convert HTML content to plain text with line breaks
                          // This is a simple approach; a more robust method might be needed for complex HTML
                          textToCopy = responseArea.innerText; // Gets visible text, preserving line breaks from rendered HTML structure
                     }
                 } else if (sourceElement === quill.root) {
                      // If in edit mode (Quill editor is visible), get the plain text from Quill
                      textToCopy = quill.getText();
                      // Remove trailing newline if Quill always adds one
                      if (textToCopy.length > 0 && textToCopy.endsWith('\n')) {
                          textToCopy = textToCopy.slice(0, -1);
                      }
                 }
            } else {
                console.error("Copy source element not found or Quill not initialized.");
                return;
            }


            // Use navigator.clipboard.writeText to copy
            navigator.clipboard.writeText(textToCopy).then(function() {
                console.log('Text successfully copied to clipboard');
                // Provide visual feedback
                copyCodeButton.textContent = '✅ Copied!';
                setTimeout(() => {
                    copyCodeButton.textContent = '📋 Copy';
                }, 2000);
            }).catch(function(err) {
                console.error('Could not copy text: ', err);
                 // Provide visual feedback for failure
                 copyCodeButton.textContent = '❌ Copy Failed';
                 setTimeout(() => {
                     copyCodeButton.textContent = '📋 Copy';
                 }, 2000);
            });
        });
    }

    if (downloadResumeTextButton) { // Renamed ID
        downloadResumeTextButton.addEventListener('click', function() {
             // Determine the source element for text: responseArea (view) or editor (edit)
            const sourceElement = responseArea.style.display !== 'none' ? responseArea : (quill ? quill.root : null); // Use quill.root for the editor's content div

            let textToDownload = '';

            if (sourceElement) {
                 if (sourceElement === responseArea) {
                     // If in view mode, get the visible text, preserving line breaks
                     if (responseArea.firstChild && responseArea.firstChild.nodeName === 'PRE') {
                         textToDownload = responseArea.firstChild.innerText;
                     } else {
                          textToDownload = responseArea.innerText;
                     }
                 } else if (sourceElement === quill.root) {
                      // If in edit mode (Quill editor is visible), get the plain text from Quill
                      textToDownload = quill.getText();
                       // Remove trailing newline if Quill always adds one
                       if (textToDownload.length > 0 && textToDownload.endsWith('\n')) {
                          textToDownload = textToDownload.slice(0, -1);
                      }
                 }
            } else {
                 console.error("Download source element not found or Quill not initialized.");
                 return;
            }


            // Create a Blob and a download link
            const blob = new Blob([textToDownload], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'customized_resume.txt'; // Set desired filename

            // Trigger the download
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href); // Clean up URL object

            console.log('Download initiated');
            // Provide visual feedback
             downloadResumeTextButton.textContent = '✅ Downloaded!';
             setTimeout(() => {
                 downloadResumeTextButton.textContent = '⬇️ Download Text';
             }, 2000);
        });
    }

    if (downloadResumePdfButton) { // New PDF button
        downloadResumePdfButton.addEventListener('click', function() {
            // Determine the source element for HTML content: responseArea (view) or editor (edit)
            const sourceElement = responseArea.style.display !== 'none' ? responseArea : (quill ? quill.root : null);

            if (!sourceElement) {
                console.error("Download PDF source element not found or Quill not initialized.");
                return;
            }

            let htmlToConvert = '';
            if (sourceElement === responseArea) {
                htmlToConvert = responseArea.innerHTML;
            } else if (sourceElement === quill.root) {
                htmlToConvert = quill.root.innerHTML;
            }

            // Create a temporary div to ensure the HTML is correctly styled for PDF conversion
            const tempDiv = document.createElement('div');
            tempDiv.style.padding = '20mm'; // Add some padding for better PDF layout
            tempDiv.innerHTML = htmlToConvert;
            document.body.appendChild(tempDiv); // Temporarily add to DOM for html2pdf to work correctly with styles

            html2pdf().from(tempDiv).set({
                margin: 10,
                filename: 'customized_resume.pdf',
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { scale: 2, logging: true, dpi: 192, letterRendering: true },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
            }).save().then(() => {
                document.body.removeChild(tempDiv); // Clean up the temporary div
                console.log('PDF download initiated');
                downloadResumePdfButton.textContent = '✅ Downloaded!';
                setTimeout(() => {
                    downloadResumePdfButton.textContent = '⬇️ Download PDF';
                }, 2000);
            }).catch(err => {
                document.body.removeChild(tempDiv); // Ensure cleanup even on error
                console.error('Error generating PDF:', err);
                downloadResumePdfButton.textContent = '❌ PDF Failed';
                setTimeout(() => {
                    downloadResumePdfButton.textContent = '⬇️ Download PDF';
                }, 2000);
            });
        });
    }


    if (emailResumeButton) {
        emailResumeButton.addEventListener('click', function() {
            // Determine the source element for text: responseArea (view) or editor (edit)
            const sourceElement = responseArea.style.display !== 'none' ? responseArea : (quill ? quill.root : null); // Use quill.root for the editor's content div


            let resumeText = "";

             if (sourceElement) {
                 if (sourceElement === responseArea) {
                     // If in view mode, get the visible text, preserving line breaks
                     if (responseArea.firstChild && responseArea.firstChild.nodeName === 'PRE') {
                         resumeText = responseArea.firstChild.innerText;
                     } else {
                          resumeText = responseArea.innerText;
                     }
                 } else if (sourceElement === quill.root) {
                      // If in edit mode (Quill editor is visible), get the plain text from Quill
                      resumeText = quill.getText();
                       // Remove trailing newline if Quill always adds one
                       if (resumeText.length > 0 && resumeText.endsWith('\n')) {
                          resumeText = resumeText.slice(0, -1);
                      }
                 }
            } else {
                 console.error("Email source element not found or Quill not initialized.");
                 return;
            }


            const subject = "My Customized Resume";
            const body = resumeText;
            // Create mailto link with encoded subject and body
            const mailtoLink = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

            // Open the user's email client
            window.location.href = mailtoLink;

            // Provide visual feedback
            emailResumeButton.classList.add('emailed');
            emailResumeButton.textContent = '📬 Email Opened';
            setTimeout(() => {
                emailResumeButton.textContent = '📧 Email';
                emailResumeButton.classList.remove('emailed');
            }, 2500);
        });
    }

    // Helper to safely get element by ID
    function getElement(id) {
        const element = document.getElementById(id);
        if (!element) {
            console.error(`Element with ID "${id}" not found.`);
        }
        return element;
    }

});
</script>


<footer>
    <p>[v0.6] © 2025 — For feedback / connecting: <a href="https://www.linkedin.com/in/masassali" target="_blank">linkedin.com/in/masassali</a> — 👍 generation count: <span id="submissionCountDisplay">Loading...</span></p>
</footer>


</body>
</html>
