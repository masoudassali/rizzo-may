<!DOCTYPE html>
<html>
<head>
<title>rizzo-may!</title>
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    line-height: 1.6;
    margin: 20px;
    background-color: #f4f7f6; /* Light background */
    color: #333; /* Default text color */
    padding-bottom: 80px; /* Add padding at the bottom to make space for the fixed footer */
  }


  h2 {
    color: #333;
    border-bottom: 2px solid #007bff; /* A little underline */
    padding-bottom: 10px;
  }


  h3 {
    color: #555;
    margin-top: 0;
    margin-bottom: 10px;
  }


  p { /* Style for general paragraphs */
      margin-bottom: 15px;
  }


  ol {
    /* margin-bottom: 20px; */
    /* padding-left: 20px; */
  }


  ol li {
      /* margin-bottom: 5px; */
  }


  /* Styles for the form container using Flexbox */
  form {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid #ccc;
    border-radius: 8px; /* More rounded corners */
    background-color: #fff; /* White form background */
    box-shadow: 0 2px 4px rgba(0 0 0 / 10%); /* Subtle shadow */
    display: flex; /* Use Flexbox for the form container */
    flex-direction: column; /* Stack form sections vertically */
    gap: 20px; /* Add space between form sections */
  }


  /* Apply box-sizing for more predictable width */
  form *, form *:before, form *:after {
    box-sizing: border-box;
  }


  /* Style for each main section within the form (message, files, button) */
  .form-section {
      display: flex;
      flex-direction: column; /* Stack elements within each section (label, input/textarea) */
      gap: 8px; /* Space between label and input/textarea */
  }


  /* --- Specific styles for the message section to accommodate dropdown suggestions --- */
  .form-section.message-section {
      /* Changed from row to column to stack textarea and dropdown */
      flex-direction: column;
      gap: 15px; /* Adjust gap for stacked items */
      flex-wrap: wrap; /* Keep wrap for mobile, though stacking makes it less critical */
      align-items: flex-start; /* Align items to the start */
      position: relative; /* Needed for absolute positioning of dropdown panel */
  }


  .message-textarea-container {
      /* Removed flex properties as it's now stacked vertically */
      display: flex; /* Use flex to stack label and textarea inside */
      flex-direction: column;
      gap: 8px; /* Space between label and textarea */
      min-width: 280px; /* Ensure minimum width */
      width: 100%; /* Make it take full width when stacked */
      flex: none; /* Ensure it doesn't try to flex */
  }


  /* Styles for the dropdown container */
  .prompt-suggestions-dropdown {
      /* Removed flex properties as it's now stacked vertically */
      min-width: 200px; /* Keep minimum width */
      position: relative; /* Container for the absolute panel */
      align-self: flex-start; /* Align to the left under the textarea */
      display: flex; /* Use flex to arrange trigger and panel */
      flex-direction: column;
      gap: 5px; /* Space between trigger and panel */
      width: auto; /* Allow width to be determined by content/min-width */
  }


  /* Style for the dropdown trigger button */
  .dropdown-trigger {
      padding: 8px 15px;
      background-color: #e9ecef;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      text-align: left; /* Align text to the left */
      width: auto; /* Allow button width to be determined by content/padding */
      transition: background-color 0.2s ease;
      display: flex; /* Use flex to align text and arrow */
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box; /* Include padding and border in width */
      min-width: 200px; /* Match container min-width */
  }


  .dropdown-trigger:hover {
      background-color: #d0d4d7;
  }


  .dropdown-panel {
      position: absolute; /* Keep absolute positioning */
      top: auto; /* Position relative to the section, below the trigger */
      bottom: auto; /* No constraint from bottom */
      left: 0; /* Align left with the dropdown trigger */
      right: auto; /* No constraint from right */
      z-index: 100; /* Ensure it appears above other content */
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: none; /* Initially hidden */
      min-width: 250px; /* Ensure readability */
      max-height: 200px; /* Add scrolling if many items */
      overflow-y: auto; /* Enable vertical scrolling */
      flex-direction: column; /* Arrange contents vertically */
      gap: 10px; /* Space between elements */
  }


  .dropdown-panel p {
      font-weight: bold;
      margin-bottom: 0;
      font-size: 0.9em;
      color: #555;
  }


  .dropdown-panel ul {
      list-style: none;
      padding: 0;
      margin: 0;
  }


  .dropdown-panel li {
      margin-bottom: 8px; /* Space between checkboxes */
      display: flex; /* Align checkbox and label */
      align-items: center;
  }


  .dropdown-panel li:last-child {
       margin-bottom: 0;
  }


  .dropdown-panel input[type="checkbox"] {
      margin-right: 8px; /* Space between checkbox and label */
      flex-shrink: 0; /* Prevent checkbox from shrinking */
  }


  .dropdown-panel label {
      font-weight: normal; /* Labels for checkboxes don't need to be bold */
      cursor: pointer; /* Indicate clickable */
      flex: 1; /* Allow label to take space */
      font-size: 0.9em;
  }


  .dropdown-panel #addSelectedPrompts {
      display: block; /* Make button block */
      width: 100%; /* Full width */
      padding: 8px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      margin-top: 10px; /* Space above button */
      transition: background-color 0.2s ease;
  }


  .dropdown-panel #addSelectedPrompts:hover {
      background-color: #0056b3;
  }




  /* --- End specific styles for message section --- */




  label {
    display: block; /* Labels are block elements */
    font-weight: bold;
    color: #555;
  }


  input[type="file"],
  textarea,
  input[type="text"] { /* Added input[type="text"] */
    display: block; /* Ensure they take up their flex area */
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f8f8f8;
    width: 100%; /* Make them fill the width of their parent flex item */
  }


  textarea {
      resize: vertical; /* Allow only vertical resizing */
      min-height: 100px; /* Give textarea a minimum height */
  }


   input[type="file"] {
       resize: none;
   }


    /* Styles for the container holding side-by-side document input groups */
    .document-inputs-container { /* New class */
        display: flex; /* Use Flexbox for side-by-side layout */
        gap: 20px; /* Space between the two document input groups */
        flex-wrap: wrap; /* Allow wrapping to a new line on smaller screens */
    }

    /* Style for each individual document input group (Flex items within document-inputs-container) */
    .document-input-group { /* New class */
        flex: 1; /* Allow each group to grow and shrink equally */
        min-width: 280px; /* Adjust minimum width */
        display: flex; /* Use Flexbox for elements within the group */
        flex-direction: column; /* Stack elements vertically within the group */
        gap: 5px; /* Space between elements */
        padding: 15px; /* Add some padding */
        border: 1px solid #ddd; /* Add a light border */
        border-radius: 5px; /* Slightly rounded corners */
        background-color: #f9f9f9; /* Light background */
    }

    .document-input-group label {
        margin-bottom: 0; /* Gap handles spacing */
        text-align: center; /* Center the label */
    }

    /* Adjust input styles to apply to text inputs as well */
    input[type="file"],
    textarea,
    input[type="text"] { /* Ensure text input is styled */
      display: block;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #f8f8f8;
      width: 100%; /* Make them fill the width */
      box-sizing: border-box; /* Include padding and border in width */
    }

    /* Style for disabled inputs */
    input[type="file"]:disabled,
    input[type="text"]:disabled {
        background-color: #e9e9e9;
        cursor: not-allowed;
    }


  /* Revised CSS for input[type="submit"] - use max-width and margin: auto, placed in its own section */
  input[type="submit"] {
    padding: 10px 20px; /* More padding */
    background-color: #007bff; /* Primary blue color */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s ease; /* Smooth hover effect */
    display: block; /* Make it a block element to use margin: auto for centering */
    width: auto; /* Let width be determined by content/padding initially */
    max-width: 300px; /* Limit maximum width on desktop */
    margin: 0 auto; /* Center the block button horizontally within its parent .form-section */
  }


  input[type="submit"]:hover {
    background-color: #0056b3; /* Darker blue on hover */
  }


  input[type="submit"]:disabled { /* Style for disabled button */
    background-color: #cccccc;
    cursor: not-allowed;
  }


  /* Styles for the upload status bar */
  #uploadStatusContainer {
      width: 100%;
      background-color: #ddd;
      display: none; /* Initially hidden */
      margin-top: 15px; /* Keep this margin */
      border-radius: 4px;
      overflow: hidden; /* Ensure the status bar stays within bounds */
  }


  #uploadStatusBar {
      width: 0%;
      height: 20px;
      background-color: #4CAF50; /* Green color for the bar */
      text-align: center;
      line-height: 20px; /* Vertically center text */
      color: white;
      border-radius: 4px;
      transition: width 0.3s ease; /* Smooth animation for the bar */
      font-size: 0.8em; /* Smaller text */
  }


   #uploadStatusText {
      margin-top: 5px; /* Keep this margin */
      font-size: 0.9em;
      color: #555;
      display: none; /* Initially hidden */
      text-align: center;
   }




  /* Styles for the response area */
  #responseContainer { /* Container for response header and the response area wrapper */
      margin-top: 20px; /* Keep this margin */
  }

  /* Style for the response header containing title and buttons */
  #responseHeader {
      display: flex; /* Use flexbox */
      align-items: center; /* Vertically align items */
      justify-content: space-between; /* Space out title and buttons */
      margin-bottom: 10px;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      gap: 10px; /* Space between items when wrapping */
  }

  /* Style for the heading within the response header */
  #responseHeader h3 {
      margin: 0; /* Remove default margin */
      flex-grow: 1; /* Allow heading to take available space */
  }

  /* Container for the buttons next to the header */
  .response-buttons {
      display: flex; /* Arrange buttons using flexbox */
      gap: 5px; /* Space between buttons */
      align-items: center; /* Vertically align buttons */
  }

  /* Style for the wrapper around responseArea to position the buttons (now removed) */
   .response-area-wrapper {
       position: relative; /* Needed for absolute positioning of the button */
       /* Removed absolute positioning styles for buttons */
   }


  /* Style for the copy code button */
  #copyCodeButton {
      /* Positioned inside response-buttons now */
      /* Removed position, top, right */
      background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
      border: 1px solid #ccc; /* Light border */
      border-radius: 4px; /* Small rounded corners */
      padding: 5px 8px; /* Add some padding */
      cursor: pointer;
      font-size: 0.8em; /* Smaller font size for the icon/text */
      color: #333; /* Dark color for the icon/text */
      transition: background-color 0.2s ease, border-color 0.2s ease;
      line-height: 1; /* Ensure consistent height */
      display: none; /* Initially hidden */
  }


  #copyCodeButton:hover {
      background-color: rgba(255, 255, 255, 1); /* Less transparent on hover */
      border-color: #bbb;
  }


  /* Optional: Style for when the text is copied */
  #copyCodeButton.copied {
      background-color: #d4edda; /* Light green */
      border-color: #c3e6cb; /* Green border */
      color: #155724; /* Dark green text */
  }


  /* Style for the new download button - position it next to the copy button */
  #downloadResumeButton {
      /* Positioned inside response-buttons now */
      /* Removed position, top, right */
      background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
      border: 1px solid #ccc; /* Light border */
      border-radius: 4px; /* Small rounded corners */
      padding: 5px 8px; /* Add some padding */
      cursor: pointer;
      font-size: 0.8em; /* Smaller font size for the icon/text */
      color: #333; /* Dark color for the icon/text */
      transition: background-color 0.2s ease, border-color 0.2s ease;
      line-height: 1; /* Ensure consistent height */
      display: none; /* Initially hidden */
  }


  #downloadResumeButton:hover {
      background-color: rgba(255, 255, 255, 1); /* Less transparent on hover */
      border-color: #bbb;
  }
   /* Optional: Style for when the text is downloaded */
  #downloadResumeButton.downloaded {
      background-color: #d4edda; /* Light green */
      border-color: #c3e6cb; /* Green border */
      color: #155724; /* Dark green text */
  }

    /* Style for the Quill editor container */
    #editor {
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 8px; /* Corrected border-radius */
        background-color: #fff; /* Use a white background for editing */
        min-height: 200px; /* Give it a decent editing height */
        width: 100%; /* Take full width */
        box-sizing: border-box; /* Include padding and border in width */
        color: #333;
        font-family: inherit; /* Inherit font from body/parent */
        font-size: inherit; /* Inherit font size */
        resize: vertical; /* Allow vertical resizing (handled by Quill's scroll) */
        margin-bottom: 10px; /* Space below textarea */
        display: none; /* Initially hidden */
        /* Quill adds its own styling, may need overrides */
    }
     /* Style for Quill's toolbar */
    .ql-toolbar {
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
         border-color: #eee;
         background-color: #f8f8f8;
    }

    /* Style for Quill's editor area (the content div) */
    .ql-container {
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        border-color: #eee;
        min-height: 200px; /* Match editor min-height */
         font-family: inherit; /* Inherit font */
         font-size: inherit; /* Inherit font size */
         color: #333;
    }


  #responseArea {
    padding: 15px;
    border: 1px solid #eee;
    border-radius: 8px;
    background-color: #e9ecef; /* Light grey background for response */
    /* white-space: pre-wrap; Removed pre-wrap as Quill outputs HTML */
    word-wrap: break-word;
    min-height: 50px; /* Give it a minimum height */
    color: #333; /* Default text color */
    overflow-x: auto; /* Add horizontal scroll if content is too wide */
     padding-right: 15px; /* Adjusted padding as buttons are moved */
     /* Ensure it can render HTML from Quill */
  }


  #responseArea pre { /* Style for pre tag inside response area */
      margin: 0; /* Remove default margin from pre */
      padding: 0;
      /* Keep pre-wrap if pre tags are still desired for initial plain text */
      white-space: pre-wrap;
  }




  #responseArea p { /* Style for paragraph messages inside response area */
      margin: 5px 0;
      padding: 0;
  }


  #responseArea code { /* Style for code blocks inside response area */
      background-color: #f8f9fa;
      padding: 2px 4px;
      border-radius: 4px;
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
      font-size: 0.9em;
  }


  /* Hide the default scrollbar on the responseArea div if you prefer the textarea's */
  #responseArea {
      overflow-y: hidden; /* Hide vertical scrollbar */
      overflow-x: auto;   /* Keep horizontal scroll if needed */
  }


  /* Style and position the new Edit button */
  #editResponseButton {
      /* Positioned inside response-buttons now */
      /* Removed position, top, right */
      z-index: 1;
      background-color: rgba(255, 255, 255, 0.8);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 5px 8px;
      cursor: pointer;
      font-size: 0.8em;
      color: #333;
      transition: background-color 0.2s ease, border-color 0.2s ease;
      line-height: 1;
      display: none; /* Initially hidden */
  }

  #editResponseButton:hover {
      background-color: rgba(255, 255, 255, 1);
      border-color: #bbb;
  }

  /* Style and position the Done Editing button */
  #doneEditingButton {
      display: block; /* Make it a block element */
      width: auto; /* Auto width based on content */
      padding: 8px 15px;
      background-color: #28a745; /* Green color */
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      margin: 10px auto; /* Center below the textarea */
      transition: background-color 0.2s ease;
  }

  #doneEditingButton:hover {
      background-color: #218838; /* Darker green on hover */
  }


  /* Styles for the footer */
  footer {
      position: fixed; /* Fix footer to the bottom */
      left: 0;
      bottom: 0;
      width: 100%;
      background-color: #333; /* Dark background */
      color: #f4f7f6; /* Light text */
      text-align: center;
      padding: 10px 20px;
      font-size: 0.8em; /* Small font size */
      z-index: 10; /* Ensure footer is above other content if needed */
  }


  footer p {
      margin: 0; /* Remove margin from footer paragraph */
      padding: 0;
  }


    footer a {
        color: #f4f7f6; /* Light color for links in footer */
        text-decoration: none; /* Remove underline */
    }


    footer a:hover {
        text-decoration: underline; /* Underline on hover */
    }


    /* Style for the counter span inside the footer */
    footer #submissionCountDisplay {
        font-weight: bold; /* Make the count stand out */
        margin-left: 5px; /* Add a little space after "Total Submissions:" */
    }




  /* Optional: Add some responsive adjustments */
  @media (max-width: 768px) { /* Adjust breakpoint for message section stacking */
      body {
          margin: 10px;
          padding-bottom: 100px; /* Increase padding for potentially taller footer on mobile */
      }
      form {
          padding: 15px;
      }
      /* Stack message section vertically on smaller screens */
      .form-section.message-section {
          flex-direction: column; /* Already column, but keeps consistency */
          gap: 15px; /* Adjust gap for vertical stacking */
          align-items: stretch; /* Allow children to stretch */
      }
       .message-textarea-container,
       .prompt-suggestions-dropdown { /* Also make dropdown container take full width */
           flex: none;
           width: 100%;
           min-width: auto;
       }
       .prompt-suggestions-dropdown {
           position: static; /* Remove absolute positioning on mobile */
           padding-bottom: 0; /* Adjust padding */
           gap: 5px;
       }


      .dropdown-panel {
          position: static; /* Remove absolute positioning on mobile */
          width: 100%; /* Take full width */
          max-height: none;
          overflow-y: visible;
          border: none;
          box-shadow: none;
          padding: 0;
          gap: 10px;
      }
       .dropdown-panel p {
           margin-top: 10px;
       }
       .dropdown-panel ul {
           padding-left: 20px;
       }
       .dropdown-panel li {
           margin-bottom: 8px; /* Keep space between checkbox items */
       }




      /* Button styles for mobile - full width, no centering */
      input[type="submit"] {
          width: 100%;
          max-width: none;
          margin: 0; /* Remove auto margin */
          text-align: center;
      }
       /* Button section on mobile - remove centering as button is full width */
      .button-section {
          align-items: stretch; /* Allow button to stretch */
      }


       /* Adjust document input groups to stack on mobile */
       .document-inputs-container { /* New class */
           flex-direction: column; /* Stack vertically on small screens */
           gap: 15px; /* Adjust gap for vertical stacking */
       }
       .document-input-group { /* New class */
           min-width: auto; /* Remove min-width constraint */
           width: 100%; /* Ensure they take full width when stacked */
           padding: 10px; /* Adjust padding */
       }

       /* Stack header and buttons on small screens */
      #responseHeader {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px; /* Increase gap */
      }

      /* Make button container full width on mobile */
      .response-buttons {
          width: 100%;
          justify-content: flex-start; /* Align buttons to the left */
      }


       /* Adjust styles for all three buttons on small screens */
       #copyCodeButton,
       #downloadResumeButton,
       #editResponseButton {
           position: static; /* Remove absolute positioning */
           margin-top: 0; /* Remove top margin */
           display: inline-block; /* Use inline-block to keep them in a row */
           width: auto; /* Auto width */
           text-align: center;
       }

        /* Adjust the wrapper if needed for mobile stacking */
        .response-area-wrapper {
            position: static;
        }
        #responseArea { /* Adjust padding if buttons were positioned over it */
            padding-top: 15px; /* Ensure text isn't hidden by buttons */
            padding-right: 15px; /* Ensure text isn't hidden by buttons */
        }

        #editor { /* Adjust padding for Quill editor on mobile */
            padding-right: 15px;
        }


        #doneEditingButton {
            width: 100%;
            margin: 10px 0; /* Adjust margin for mobile */
        }


        footer {
            font-size: 0.7em; /* Smaller font on small screens */
            padding: 8px 10px;
            line-height: 1.4; /* Adjust line height for smaller font */
        }
        footer p {
            margin: 0; /* Ensure no extra margin */
        }


  }


</style>
</head>
<body>


<h2>rizzo-may! <span style="font-size: smaller;"><i>(test page -- use index.html for prod.)</i></span></h2>
<p>Of course you may use AI to customize your resume to job applications. <b><i>(it's free.)</i></b><br><b>3 simple steps: </b></p>

<form id="uploadForm" enctype="multipart/form-data" action="https://steak.servequake.com/webhook-test/c04f5180-4675-45b0-ae75-ce70eeb625d8" method="POST">
  <div class="form-section message-section">
    <div class="message-textarea-container">
        <label for="userMessage">[Optional] Add a focus to your resume. (Choose from the suggestions below or add your own.)</label>
        <textarea name="userMessage" id="userMessage" rows="4" cols="50"></textarea>
    </div>
    <div class="prompt-suggestions-dropdown">
        <button id="promptDropdownTrigger" class="dropdown-trigger">Add Suggestions <span class="arrow">▼</span></button>
        <div id="promptDropdownPanel" class="dropdown-panel">
            <button id="addSelectedPrompts">Add Selected</button>
            <p>Select suggestions to add:</p>
            <ul>
                <li><input type="checkbox" id="prompt-1" data-prompt="Clean up and proofread"><label for="prompt-1">Clean up and proofread</label></li>
                <li><input type="checkbox" id="prompt-4" data-prompt="Incorporate ATS keywords"><label for="prompt-4">Incorporate ATS keywords</label></li>
                <li><input type="checkbox" id="prompt-5" data-prompt="Strengthen using action verbs and numbers"><label for="prompt-5">Strengthen using action verbs and numbers</label></li>
                <li><input type="checkbox" id="prompt-6" data-prompt="Condense to one page"><label for="prompt-6">Condense to one page</label></li>
                 <li><input type="checkbox" id="prompt-2" data-prompt="Use [Industry] terms"><label for="prompt-2">Use [Industry] terms</label></li>
                <li><input type="checkbox" id="prompt-3" data-prompt="Emphasize [Skill] experience"><label for="prompt-3">Emphasize [Skill] experience</label></li>
            </ul>
        </div>
    </div>
  </div>

  <div class="form-section">
    <p><b>Provide your Resume and the Job Description:</b> <i>(.txt, .pdf, .docx files < 1mb please. You can mix & match formats and input types.)</i></p>

    <div class="document-inputs-container"> <div class="document-input-group"> <label for="resumeInput">Add Resume:</label> <input type="file" name="resumeFile" id="resumeFile"> <p style="text-align: center; margin: 5px 0; font-size: 0.9em; color: #555;">- OR -</p>
        <input type="text" name="resumeUrl" id="resumeUrl" placeholder="Enter Resume URL"> </div>

      <div class="document-input-group"> <label for="jdInput">Add Job Description:</label> <input type="file" name="jdFile" id="jdFile"> <p style="text-align: center; margin: 5px 0; font-size: 0.9em; color: #555;">- OR -</p>
        <input type="text" name="jdUrl" id="jdUrl" placeholder="Enter JD URL"> </div>

    </div>
     <p style="font-size: 0.9em; color: #666; margin-top: 5px;"><i>(For each document, provide either a file upload OR a URL.)</i></p>
  </div>
  <div class="form-section button-section">
    <input type="submit" value="Generate Resume">
  </div>


</form>


<div id="uploadStatusContainer">
  <div id="uploadStatusBar">0%</div>
</div>
<div id="uploadStatusText">Uploading...</div>




<div id="responseContainer" style="display: none;">
    <div id="responseHeader">
        <h3>Your customized rizzo-may:</h3>
        <div class="response-buttons">
            <button id="editResponseButton" title="Edit on the spot">Edit on the spot</button>
            <button id="copyCodeButton" title="Copy to clipboard">📋 Copy</button>
            <button id="downloadResumeButton" title="Download Resume">⬇️ Download</button>
        </div>
    </div>
    <div class="response-area-wrapper">
        <div id="responseArea"></div>
        <div id="editor" style="display: none;"></div>
        <button id="doneEditingButton" style="display: none;" title="Done Editing">✅ Done Editing</button>
    </div>
</div>

<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

<script>
// Global variable for the counter span element
let counterDisplaySpan = null;
const localStorageKey = 'rizzoooMaySubmissionCount';
let currentCount = localStorage.getItem(localStorageKey); // Read initial count globally
let quill = null; // Variable to hold the Quill editor instance


// Wait for the DOM to be fully loaded before initializing most script parts
document.addEventListener('DOMContentLoaded', function() {


    // --- Submission Counter Initialization ---
    // Get the counter span element once the DOM is loaded
    counterDisplaySpan = document.getElementById('submissionCountDisplay');


    // Check if the element was found
    if (!counterDisplaySpan) {
        console.error("Submission count display span not found in footer! Counter will not display.");
        // No need to exit here, other parts of the script can still run
    } else {
         // Update the text content of the span with the current count on load
        if (currentCount === null || isNaN(parseInt(currentCount, 10))) { // Also checks if initial read was NaN
            currentCount = 431; // Start count if no previous valid count is found
            localStorage.setItem(localStorageKey, currentCount); // Save initial count
        } else {
             currentCount = parseInt(currentCount, 10); // Ensure it's a number
        }
        counterDisplaySpan.textContent = currentCount;
    }


    // --- Prompt Suggestions Dropdown Functionality ---
    const dropdownTrigger = document.getElementById('promptDropdownTrigger');
    const dropdownPanel = document.getElementById('promptDropdownPanel');
    const addSelectedButton = document.getElementById('addSelectedPrompts');


    // Toggle dropdown visibility
    dropdownTrigger.addEventListener('click', function(event) {
        event.stopPropagation(); // Prevent click from bubbling up and closing immediately
        const isVisible = dropdownPanel.style.display === 'flex'; // Check current display style
        dropdownPanel.style.display = isVisible ? 'none' : 'flex'; // Toggle between none and flex
        // Adjust arrow direction (optional)
        const arrow = this.querySelector('.arrow');
        if(arrow) {
            arrow.textContent = isVisible ? '▼' : '▲';
        }
    });


    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
        // If the click is not inside the dropdown trigger AND not inside the dropdown panel
        if (!dropdownTrigger.contains(event.target) && !dropdownPanel.contains(event.target)) {
            dropdownPanel.style.display = 'none'; // Hide the panel
             // Reset arrow (optional)
             const arrow = dropdownTrigger.querySelector('.arrow');
             if(arrow) { arrow.textContent = '▼'; }
        }
    });


    // Prevent dropdown from closing when clicking inside the panel (except on the Add button, handled below)
    dropdownPanel.addEventListener('click', function(event) {
        event.stopPropagation(); // Stop the click from bubbling up to the document
    });




    // Handle adding selected prompts to the textarea
    addSelectedButton.addEventListener('click', function() {
        const textarea = document.getElementById('userMessage');
        const checkboxes = dropdownPanel.querySelectorAll('input[type="checkbox"]:checked');
        let selectedPromptsText = '';


        checkboxes.forEach(checkbox => {
            // Get the prompt text from the data-prompt attribute
            const promptText = checkbox.dataset.prompt || checkbox.nextElementSibling.textContent; // Use label text as fallback
            selectedPromptsText += promptText + '\n'; // Append prompt text followed by a newline
            checkbox.checked = false; // Uncheck the box after adding
        });


        // Append the collected prompts to the textarea
        if (selectedPromptsText.length > 0) {
             // Add a newline before the first added prompt if the textarea isn't empty and doesn't end with newline
             const prefix = textarea.value.length > 0 && !textarea.value.endsWith('\n') ? '\n' : '';
             textarea.value += prefix + selectedPromptsText;


             // Optional: Scroll textarea to the bottom
             textarea.scrollTop = textarea.scrollHeight;


             // Optional: Focus the textarea
             textarea.focus();
        }


        // Hide the dropdown panel after adding
        dropdownPanel.style.display = 'none';
         // Reset arrow (optional)
        const arrow = dropdownTrigger.querySelector('.arrow');
        if(arrow) { arrow.textContent = '▼'; }


    });

    // --- Mutually Exclusive Document Input (File or URL) ---
    const resumeFile = document.getElementById('resumeFile');
    const resumeUrl = document.getElementById('resumeUrl');
    const jdFile = document.getElementById('jdFile');
    const jdUrl = document.getElementById('jdUrl');

    const updateResumeInputState = () => {
        if (resumeUrl.value.trim() !== '') {
            // Resume URL has text, disable Resume file input
            resumeFile.disabled = true;
            // resumeFile.required = false; // We'll handle required validation in the submit handler or backend
        } else {
            // Resume URL is empty, enable Resume file input
            resumeFile.disabled = false;
            // resumeFile.required = true; // We'll handle required validation
        }
    };

    const updateJdInputState = () => {
        if (jdUrl.value.trim() !== '') {
            // JD URL has text, disable JD file input
            jdFile.disabled = true;
            // jdFile.required = false; // We'll handle required validation
        } else {
            // JD URL is empty, enable JD file input
            jdFile.disabled = false;
            // jdFile.required = true; // We'll handle required validation
        }
    };

    // Add event listeners for Resume inputs
    resumeUrl.addEventListener('input', updateResumeInputState);
    resumeFile.addEventListener('change', () => {
        if (resumeFile.files.length > 0) {
            resumeUrl.value = ''; // Clear URL if a file is selected
        }
        updateResumeInputState(); // Update states after change
    });

    // Add event listeners for JD inputs
    jdUrl.addEventListener('input', updateJdInputState);
    jdFile.addEventListener('change', () => {
        if (jdFile.files.length > 0) {
            jdUrl.value = ''; // Clear URL if a file is selected
        }
        updateJdInputState(); // Update states after change
    });


    // Initial check on page load
    updateResumeInputState();
    updateJdInputState();

    // --- Add Validation to Form Submission ---
    const uploadForm = document.getElementById('uploadForm');
    uploadForm.addEventListener('submit', function(event) {
        event.preventDefault(); // <--- THIS LINE PREVENTS DEFAULT FORM SUBMISSION

        const form = this;
        const responseArea = document.getElementById('responseArea');
        const responseContainer = document.getElementById('responseContainer');
        const uploadStatusContainer = document.getElementById('uploadStatusContainer');
        const uploadStatusBar = document.getElementById('uploadStatusBar');
        const uploadStatusText = document.getElementById('uploadStatusText');
        const submitButton = form.querySelector('input[type="submit"]');

         // --- Get elements for editing feature ---
        const editorContainer = document.getElementById('editor'); // The div for Quill editor
        const editResponseButton = document.getElementById('editResponseButton'); // The Edit button
        const doneEditingButton = document.getElementById('doneEditingButton'); // The Done Editing button
        const copyCodeButton = document.getElementById('copyCodeButton'); // The Copy button
        const downloadResumeButton = document.getElementById('downloadResumeButton'); // The Download button


        // Add validation: Check if either a file OR a URL is provided for Resume and JD
        const isResumeProvided = (resumeFile.files.length > 0 || resumeUrl.value.trim() !== '');
        const isJdProvided = (jdFile.files.length > 0 || jdUrl.value.trim() !== '');

        if (!isResumeProvided || !isJdProvided) {
            alert("Please provide either a file or a URL for both your Resume and the Job Description.");
            // Re-enable form elements and submit button if validation fails
             const submitButton = uploadForm.querySelector('input[type="submit"]');
             submitButton.disabled = false; // Make sure button is enabled
             // Re-enable inputs if they were disabled by the URL/File logic
              updateResumeInputState(); // This will re-enable file input if URL is empty
              updateJdInputState();   // This will re-enable file input if URL is empty

              // Re-enable other disabled elements that aren't part of the file/URL exclusive logic
               form.querySelectorAll('input, textarea, button').forEach(element => {
                 // Ensure we don't accidentally enable the submit button again here
                 // Also make sure to not enable the edit/done buttons as they are for the results area
                 if (element !== submitButton && element !== editResponseButton && element !== doneEditingButton && element !== copyCodeButton && element !== downloadResumeButton && element.id !== 'promptDropdownTrigger' && !element.closest('.dropdown-panel')) { // Exclude dropdown trigger/panel elements and response buttons
                     element.disabled = false;
                 }
             });


            // Hide any status messages that might have appeared prematurely
             document.getElementById('uploadStatusContainer').style.display = 'none';
             document.getElementById('uploadStatusText').style.display = 'none';

            return; // Stop the function
        }

        // If validation passes, proceed with FormData
        const formData = new FormData(this); // Use 'this' to refer to the form


        // --- Disable elements and show status before XHR ---
         // Disable all input elements and the submit button in the form
         form.querySelectorAll('input, textarea, button').forEach(element => {
            // Keep the dropdown trigger enabled so the user can still access suggestions
            // Also ensure edit/done/copy/download buttons are not affected here (they are for results)
            if (element !== submitButton && element !== editResponseButton && element !== doneEditingButton && element !== copyCodeButton && element !== downloadResumeButton && element.id !== 'promptDropdownTrigger' && !element.closest('.dropdown-panel')) {
                 element.disabled = true;
            }
        });
         submitButton.disabled = true;


        // --- Reset and Show UI Elements ---
        responseContainer.style.display = 'block';
        // Initial text for response area while generating
        responseArea.innerHTML = 'Generating... shouldn\'t take more than a couple of minutes.';
        responseArea.style.color = '#000'; // Reset to default text color
        responseArea.style.backgroundColor = '#e9ecef'; // Reset to default background
        responseArea.style.borderColor = '#eee'; // Reset to default border

        // Ensure editing elements are hidden when starting new submission
        editorContainer.style.display = 'none'; // Hide Quill editor div
        doneEditingButton.style.display = 'none';
        // Ensure view elements are shown initially
        responseArea.style.display = 'block';
        // Hide the response buttons initially
        editResponseButton.style.display = 'none';
        copyCodeButton.style.display = 'none';
        downloadResumeButton.style.display = 'none';


        uploadStatusContainer.style.display = 'block';
        uploadStatusText.style.display = 'block';
        uploadStatusBar.style.width = '0%'; // Reset progress bar width
        uploadStatusBar.innerHTML = '0%'; // Reset percentage text inside bar
        // Status text below the bar
        uploadStatusText.innerHTML = "Starting upload...";

        // --- Create and Configure XMLHttpRequest ---
        const xhr = new XMLHttpRequest();


        // --- Track Upload Progress ---
        xhr.upload.onprogress = function(event) {
            if (event.lengthComputable) {
                const percentComplete = (event.loaded / event.total) * 100;
                const percent = Math.round(percentComplete); // Round for display
                // Update progress bar width
                uploadStatusBar.style.width = percent + '%';
                // Update the text inside the status bar div (e.g., "0%", "50%", "100%")
                uploadStatusBar.innerHTML = percent + '%';
                // Update text below the bar during upload
                 uploadStatusText.innerHTML = `Uploading files (${percent}%)...`;


            }
        };


        // --- Handle Upload Complete (before response starts) ---
        xhr.onloadstart = function() {
             // Upload is likely complete here, transition to processing
             uploadStatusBar.style.width = '100%'; // Set bar to full
             uploadStatusBar.innerHTML = '100%'; // Show 100% in bar
             uploadStatusText.innerHTML = "Processing... shouldn\'t take more than a couple of minutes."; // Change text below bar
        };


         // Function to re-enable form elements (call this on completion/error)
         const reEnableForm = () => {
              // Re-enable resume/JD inputs based on their last state before disabling
              updateResumeInputState();
              updateJdInputState();
              // Re-enable other form elements (like the message textarea)
              form.querySelectorAll('textarea, button').forEach(element => {
                 // We want the submit button to remain disabled until refresh, so don't re-enable it here
                 // Ensure edit/done/copy/download buttons are not affected here (they are for results area)
                 if (element !== submitButton && element !== editResponseButton && element !== doneEditingButton && element !== copyCodeButton && element !== downloadResumeButton && element.id !== 'promptDropdownTrigger' && !element.closest('.dropdown-panel')) {
                     element.disabled = false;
                 }
             });
         };


        // --- Handle Request Completion (Success or Failure) ---
        xhr.onload = function() {
            // Request has completed (either success or failure status)


            // submitButton.disabled = false; // REMOVED: Keep button disabled until refresh
            reEnableForm(); // Re-enable other form elements


            // Set final status text inside the bar (will be hidden shortly)
            if(uploadStatusBar) { // Check exists
               uploadStatusBar.innerHTML = xhr.status >= 200 && xhr.status < 300 ? 'Complete!' : 'Error!'; // Show final status in bar
            }




            if (xhr.status >= 200 && xhr.status < 300) {
                // Request was successful (HTTP status 2xx)


                // --- Increment and save counter on successful submission ---
                // Only increment if the counter span was found initially
                if (counterDisplaySpan) {
                    // Ensure currentCount is a number before incrementing
                     if (typeof currentCount !== 'number' || isNaN(currentCount)) {
                         // If for some reason currentCount isn't a number here, re-read it
                         currentCount = localStorage.getItem(localStorageKey);
                         if (currentCount === null || isNaN(parseInt(currentCount, 10))) {
                            currentCount = 431;
                         } else {
                             currentCount = parseInt(currentCount, 10);
                         }
                     }
                    currentCount++;
                    localStorage.setItem(localStorageKey, currentCount);
                    // Update the text content of the span in the footer
                    counterDisplaySpan.textContent = currentCount;
                }
                // --- End counter update ---


                try {
                    const data = JSON.parse(xhr.responseText); // Attempt to parse the JSON response from client


                    // Display the response from client (assuming JSON with customizedResume key)
                    const customizedResumeText = data.customizedResume || JSON.stringify(data, null, 2); // Use customizedResume if present, fallback to full JSON


                     // Display text nicely formatted in responseArea
                     responseArea.innerHTML = customizedResumeText;


                    // Update final status text below the bar on success
                    uploadStatusText.innerHTML = "Generated!";


                    responseArea.style.color = '#333'; // Dark grey for success
                    responseArea.style.backgroundColor = '#e9ecef'; // Light grey, consistent with original response area background
                    responseArea.style.borderColor = '#eee'; // Light border, consistent with original response area border


                    // --- Show the edit/copy/download buttons after successful generation ---
                    editResponseButton.style.display = 'inline-block';
                    copyCodeButton.style.display = 'inline-block';
                    downloadResumeButton.style.display = 'inline-block';

                    // Ensure button display styles are correct after switching
                    if (window.innerWidth <= 768) { // Adjust for mobile layout if needed
                        editResponseButton.style.display = 'block';
                        copyCodeButton.style.display = 'block';
                        downloadResumeButton.style.display = 'block';
                    }
                     // --- End show buttons ---


                } catch (e) {
                    // Failed to parse the JSON response (e.g., client returned plain text or invalid JSON on success)
                    console.error('Error parsing JSON response:', e, 'Response:', xhr.responseText);
                    responseArea.innerHTML = '<p>Error: Received unexpected response from client.</p><p><code>' + (xhr.responseText || 'No response text').substring(0, 500) + '...</code></p>'; // Display partial response text


                    // Update final status text below the bar on parse error
                    uploadStatusText.innerHTML = "Generation failed (Parse Error).";


                    responseArea.style.color = '#721c24'; // Dark red for error
                    responseArea.style.backgroundColor = '#f8d7da'; // Light red for error background
                    responseArea.style.borderColor = '#f5c6cb';

                    // Hide edit/copy/download buttons on error
                    editResponseButton.style.display = 'none';
                    copyCodeButton.style.display = 'none';
                    downloadResumeButton.style.display = 'none';
                }


            } else {
                // Request failed (HTTP status is not 2xx)
                console.error('HTTP error!', xhr.status, xhr.responseText);
                let errorMessage = `HTTP error! status: ${xhr.status}`;
                try {
                    // Attempt to parse client's error response if it's JSON
                    const errorResponse = JSON.parse(xhr.responseText);
                    if (errorResponse.message) {
                        errorMessage += `, message: ${errorResponse.message}`;
                    } else {
                        errorMessage += `, body: ${xhr.responseText}`;
                    }
                } catch (e) {
                    // If response isn't JSON, just include the status and response text
                    errorMessage += `, body: ${xhr.responseText}`;
                }


                responseArea.innerHTML = '<p>Error processing files:</p><p><code>' + errorMessage + '</code></p>';
                 // Update final status text below the bar on HTTP error
                uploadStatusText.innerHTML = `Error: ${xhr.status}`;


                responseArea.style.color = '#721c24';
                responseArea.style.backgroundColor = '#f8d7da';
                responseArea.style.borderColor = '#f5c6cb';

                 // Hide edit/copy/download buttons on error
                editResponseButton.style.display = 'none';
                copyCodeButton.style.display = 'none';
                downloadResumeButton.style.display = 'none';
            }
             // Update status text inside the bar to indicate completion or error
            if(uploadStatusBar) { // Check exists
                 // This was already set above, keep it consistent
                 // uploadStatusBar.innerHTML = uploadStatusText.innerHTML;
            }


            // Hide status bar container (the bar itself)
            uploadStatusContainer.style.display = 'none';
            // Keep uploadStatusText visible with the final message


        }; // End xhr.onload


        // --- Handle Network Errors (like connection refused) ---
        xhr.onerror = function() {
            console.error('Network error!');
            // Hide status bar container
            uploadStatusContainer.style.display = 'none';
            // uploadStatusText.style.display = 'none'; // Keep status text visible
            // submitButton.disabled = false; // REMOVED: Keep button disabled until refresh
            reEnableForm(); // Re-enable other form elements


            responseArea.innerHTML = '<p>Error processing files:</p><p><code>Network request failed. Please check your connection or the server status.</code></p>';
            responseArea.style.color = '#721c24';
            responseArea.style.backgroundColor = '#f8d7da';
            responseArea.style.borderColor = '#f5c6cb';
             // Update final status text below the bar on network error
            uploadStatusText.innerHTML = "Network error.";
            // Update status text inside the bar
             if(uploadStatusBar) { uploadStatusBar.innerHTML = "Error!"; }

             // Hide edit/copy/download buttons on error
            editResponseButton.style.display = 'none';
            copyCodeButton.style.display = 'none';
            downloadResumeButton.style.display = 'none';
        };


        // --- Handle Request Timeout ---
        xhr.ontimeout = function() {
            console.error('Request timed out!');
            uploadStatusContainer.style.display = 'none';
            // uploadStatusText.style.display = 'none'; // Keep status text visible
            // submitButton.disabled = false; // REMOVED: Keep button disabled until refresh
            reEnableForm(); // Re-enable other form elements


            responseArea.innerHTML = '<p>Error processing files:</p><p><code>Request timed out. The server took too long to respond.</code></p>';
            responseArea.style.color = '#721c24';
            responseArea.style.backgroundColor = '#f8d7da';
            responseArea.style.borderColor = '#f5c6cb';
             // Update final status text below the bar on timeout error
            uploadStatusText.innerHTML = "Request timed out.";
            // Update status text inside the bar
             if(uploadStatusBar) { uploadStatusBar.innerHTML = "Timeout!"; }

            // Hide edit/copy/download buttons on error
            editResponseButton.style.display = 'none';
            copyCodeButton.style.display = 'none';
            downloadResumeButton.style.display = 'none';
        };


        // --- Open and Send the Request ---
        // IMPORTANT: Replace the action URL with your actual production client webhook URL
        xhr.open(this.method, this.action); // Use the form's method (POST) and action URL
        // When sending FormData with XHR, the browser automatically sets the Content-Type
        // and boundary header correctly. Do NOT set Content-Type manually here.


        xhr.send(formData); // Send the FormData object containing both files and textarea data


    });

    // --- Edit Response Area (Quill) Functionality ---
    const responseArea = document.getElementById('responseArea');
    const editorContainer = document.getElementById('editor'); // Div for Quill
    const editResponseButton = document.getElementById('editResponseButton');
    const doneEditingButton = document.getElementById('doneEditingButton');
    const copyCodeButton = document.getElementById('copyCodeButton');
    const downloadResumeButton = document.getElementById('downloadResumeButton');

    // Initialize Quill when DOM is ready
     // Configure Quill toolbar options
    const toolbarOptions = [
        ['bold', 'italic', 'underline', 'strike'],        // toggled buttons
        ['blockquote', 'code-block'],

        [{ 'header': 1 }, { 'header': 2 }],               // custom button values
        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
        [{ 'script': 'sub'}, { 'script': 'super' }],      // superscript/subscript
        [{ 'indent': '-1'}, { 'indent': '+1' }],          // outdent/indent
        [{ 'direction': 'rtl' }],                         // text direction

        [{ 'size': ['small', false, 'large', 'huge'] }],  // custom dropdown
        [{ 'header': [1, 2, 3, 4, 5, 6, false] }],

        [{ 'color': [] }, { 'background': [] }],          // dropdown with defaults from theme
        [{ 'font': [] }],
        [{ 'align': [] }],

        ['clean']                                         // remove formatting button
    ];

    quill = new Quill(editorContainer, {
        modules: {
            toolbar: toolbarOptions // Use the defined toolbar options
        },
        theme: 'snow' // 'snow' or 'bubble' theme
    });


    // Function to switch to editing mode
    const switchToEditMode = () => {
        // Get the current HTML content from responseArea
        // If the content is wrapped in <pre>, get the text inside
        let contentToEdit = responseArea.innerHTML;
        if (contentToEdit.startsWith('<pre>') && contentToEdit.endsWith('</pre>')) {
            contentToEdit = responseArea.innerText; // Get plain text inside pre
             // Convert plain text with newlines to simple HTML paragraphs for Quill
             contentToEdit = contentToEdit.split('\n').map(line => `<p>${line}</p>`).join('');
        } else {
             // Use innerHTML directly if it's not pre-formatted
             // Might need more robust conversion if responseArea contains complex HTML
        }


        // Set the Quill editor's content with the HTML
        quill.root.innerHTML = contentToEdit;


        // Hide the responseArea div and the Copy/Download/Edit buttons
        responseArea.style.display = 'none';
        editResponseButton.style.display = 'none';
        copyCodeButton.style.display = 'none';
        downloadResumeButton.style.display = 'none';


        // Show the Quill editor div and the "Done Editing" button
        editorContainer.style.display = 'block';
        doneEditingButton.style.display = 'block';

        // Optional: Focus the editor
        quill.focus();
    };

    // Function to switch back to viewing mode
    const switchToViewMode = () => {
        // Get the edited HTML content from the Quill editor
        const editedHtml = quill.root.innerHTML;

        // Update the responseArea div's content with the HTML
        responseArea.innerHTML = editedHtml;

        // Hide the Quill editor div and the "Done Editing" button
        editorContainer.style.display = 'none';
        doneEditingButton.style.display = 'none';

        // Show the responseArea div
        responseArea.style.display = 'block';

        // Always show the edit, copy, and download buttons after coming back from editing
        if (window.innerWidth <= 768) { // Adjust for mobile layout if needed
            editResponseButton.style.display = 'block';
            copyCodeButton.style.display = 'block';
            downloadResumeButton.style.display = 'block';
        } else { // Desktop layout
            editResponseButton.style.display = 'inline-block';
            copyCodeButton.style.display = 'inline-block';
            downloadResumeButton.style.display = 'inline-block';
        }
    };


    // Add event listener to the Edit button
    if (editResponseButton) {
        editResponseButton.addEventListener('click', switchToEditMode);
    } else {
        console.error("Edit response button not found!");
    }

    // Add event listener to the "Done Editing" button
    if (doneEditingButton) {
        doneEditingButton.addEventListener('click', switchToViewMode);
    } else {
        console.error("Done Editing button not found!");
    }

    // --- Copy to Clipboard Functionality ---
    if (copyCodeButton) {
        copyCodeButton.addEventListener('click', function() {
            // Determine which element is currently visible and contains the text
            const sourceElement = responseArea.style.display !== 'none' ? responseArea : editorContainer; // Check if responseArea or editor is visible
            let textToCopy;

            if (sourceElement === editorContainer) {
                 // Get plain text from Quill editor
                 textToCopy = quill.getText();
                 // Quill adds a trailing newline, remove it if it's the only character
                 if (textToCopy.length > 1 && textToCopy.endsWith('\n')) {
                     textToCopy = textToCopy.slice(0, -1);
                 }
            } else {
                // Get plain text from responseArea
                textToCopy = sourceElement.innerText;
            }


            navigator.clipboard.writeText(textToCopy).then(function() {
                /* clipboard successfully set */
                console.log('Text successfully copied to clipboard');
                // Optional: Provide visual feedback to the user
                copyCodeButton.textContent = '✅ Copied!';
                setTimeout(() => {
                    copyCodeButton.textContent = '📋 Copy'; // Reset button text after a delay
                }, 2000); // Reset after 2 seconds


            }).catch(function(err) {
                /* clipboard write failed */
                console.error('Could not copy text: ', err);
                 // Optional: Provide visual feedback for failure
                 copyCodeButton.textContent = '❌ Copy Failed';
                 setTimeout(() => {
                     copyCodeButton.textContent = '📋 Copy'; // Reset button text after a delay
                 }, 2000); // Reset after 2 seconds
            });
        });
    } else {
        console.error("Copy code button not found!");
    }


    // --- Download Resume Functionality ---
    if (downloadResumeButton) {
        downloadResumeButton.addEventListener('click', function() {
             // Determine which element is currently visible and contains the text
            const sourceElement = responseArea.style.display !== 'none' ? responseArea : editorContainer; // Check if responseArea or editor is visible
            let textToDownload;

            if (sourceElement === editorContainer) {
                 // Get plain text from Quill editor
                 textToDownload = quill.getText();
                  // Quill adds a trailing newline, remove it if it's the only character
                 if (textToDownload.length > 1 && textToDownload.endsWith('\n')) {
                     textToDownload = textToDownload.slice(0, -1);
                 }
            } else {
                // Get plain text from responseArea
                textToDownload = sourceElement.innerText;
            }


            // Create a Blob with the text content
            const blob = new Blob([textToDownload], { type: 'text/plain' });


            // Create a link element
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'customized_resume.txt'; // Set the desired filename


            // Append the link to the body (required for Firefox)
            document.body.appendChild(a);


            // Trigger the click event on the link
            a.click();


            // Remove the link from the document
            document.body.removeChild(a);


            // Revoke the object URL to free up memory
            URL.revokeObjectURL(a.href);


            console.log('Download initiated');
             // Optional: Provide visual feedback to the user
             downloadResumeButton.textContent = '✅ Downloaded!';
             setTimeout(() => {
                 downloadResumeButton.textContent = '⬇️ Download'; // Reset button text after a delay
             }, 2000); // Reset after 2 seconds
        });
    } else {
        console.error("Download resume button not found!");
    }




    // --- IMPORTANT: Update xhr.onload success handler ---
    // Find the xhr.onload function in your script:
    // Inside the `if (xhr.status >= 200 && xhr.status < 300)` block (success):
    // After `responseArea.innerHTML = ...;` and `uploadStatusText.innerHTML = "Generated!";`
    // Ensure the view mode is set correctly and buttons are visible:
    /*
    // Example within xhr.onload success block:
    if (xhr.status >= 200 && xhr.status < 300) {
        // ... your existing success code ...

        try {
             // ... JSON parsing and responseArea.innerHTML update ...

             uploadStatusText.innerHTML = "Generated!";

             // --- Ensure view mode is set after results are loaded ---
             // This makes the responseArea div visible and hides the textarea
             // It also handles showing the buttons based on screen size
             // NOTE: This call is already present and correct.
             // switchToViewMode();


         } catch(e) {
             // ... error parsing JSON ...
         }

    } // ... rest of xhr.onload (error handling etc) ...

    */
    // You already have a call to switchToViewMode() in your xhr.onload success block,
    // which is good! Just make sure it's correctly placed after responseArea.innerHTML is set.


}); // End DOMContentLoaded listener



</script>


<footer>
    <p>[v0.6] © 2025 — For feedback / connecting: <a href="https://www.linkedin.com/in/masassali" target="_blank">linkedin.com/in/masassali</a> — 👍 generation count: <span id="submissionCountDisplay">Loading...</span></p>
</footer>


</body>
</html>
